#!/usr/bin/env ruby

# # #
# gems used:
#  https://github.com/ktheory/maildir
#  https://github.com/mikel/mail
#
# Architecture
# 1. a script that extracts instructions from user emails
#    and writes this data into another file (vacations.yaml)
# 2. TODO: a script that installs and removes Sieve scripts
#    according to vacation.yaml.
#    Notification should be sent to the user both when
#    the script is installed or removed
#    Ensure that (de)activation succeeds even if the datetime
#    is in the past.
# 
# Include in the help message:
#  - works with Maildir format only
#
# 1. avoid processing autoreplies :)
# TODO: wrap into VacationAutoresponder class?


require 'maildir'
require 'mail'
require 'yaml'

@mailboxes_dir = "/home/mkrot/projects/my-linux-tools/tmp/"
@dovecot_users_file = "/home/mkrot/projects/my-linux-tools/tmp/users"
@debug = false

@smtp_config_file = @mailboxes_dir + "/smtp.conf"

######################################################################
# Mailer configuration

class Hash
  def symbolize_keys
    each_with_object({}) do |(k,v), hash|
      hash[k.to_sym] = v
    end
  end
end

smtp_config = YAML.load_file(@smtp_config_file).symbolize_keys

Mail.defaults do
  delivery_method :smtp, smtp_config
end

######################################################################

class Vacation
  attr_reader   :starts_at, :ends_at
  attr_reader   :activated_at, :deactivated_at
  attr_accessor :requested_at
  attr_accessor :account_name, :account_email
  attr_accessor :email_file

  attr_accessor :closed

  def self.howto
    outs = []
    outs << "1) How to activate autoresponder. when becomes effective."
    outs << "2) How to cancel autoresponder. when becomes effective"
    outs << "3) when syntax is incorrect, this message is sent."
    outs.join("\n")
  end

  def initialize text
    @closed = false
    @parsing_message = false
    @valid_request = false

    parse text
  end

  # TODO: test if works with html
  def parse text

    puts "=== parsing text to find Vacation ==="
    puts text

    text.split(/\n/).each do |line|
      line.chomp!
      if line =~ /^=vacation/
        reset_parsed
      elsif line =~ /=end/
        @closed = true
        break
      elsif line =~ /^cancel/
        cancel
      elsif line =~ /^first (?:day|date):(.+)/
        @starts_at = $1
      elsif line =~ /^last (?:day|date):(.+)/
        @ends_at = $1
      elsif line =~ /^message:(.*)/
        @message = $1.strip
        @parsing_message = true
      elsif parsing_message?
        @message << "\n" << line
      end
    end

    # simple test to discriminate valid and invalid vacation requests
    fields = [:starts_at, :ends_at]
    if fields.all?{ |f| send(f) }
      @valid_request = true
    end
  end

  def reset_parsed
    @starts_at = @ends_at = nil
    @message = nil
    @parsing_message = false
  end

  def starts_at= val
    @parsing_message = false
    @starts_at = val.is_a?(Date) ? val : Date.parse(val)
    @activated_at = @starts_at
  end

  def ends_at= val
    @parsing_message = false
    @ends_at = val.is_a?(Date) ? val : Date.parse(val)
    @deactivated_at = @ends_at
  end

  def message
    @message || message_default
  end

  def message_default
    'I am on vacation. Hopefully will manage to get back from Egypt.'
  end

  def parsing_message?
    @parsing_message
  end

  def cancel
    @canceled = true
    @valid_request = true
    @deactivated_at = Time.now
  end

  def canceled?
    @canceled
  end

  def valid_request?
    @valid_request
  end

  def to_s
    out = []
    out << "account: #{account_name}"
    out << "email: #{account_email}"
    if canceled?
      out << "vacation: canceled"
    else
      out << "from: #{starts_at}"
      out << "till: #{ends_at}"
      out << "message:\n#{message}\nend_of_message"
      out << "*requested at: #{requested_at}"
      out << "*email path: #{email_file.path}"
    end
    out.join("\n")
  end

  private

  def closed= v
    @closed = v
    @parsing_message = false  if @closed
  end

end

######################################################################

def senders_in_our_domain msg
  # as per RFC, the From field can contain several addresses
  senders = msg.from.select do |addr|
    username, domain, other = addr.split '@'
    @our_domains.include?(domain.downcase)
  end
  senders
end

def mail_to_me? msg
  rcpt_addresses = [:to, :cc].map do |meth|
    msg.send(meth)
  end.flatten.compact.map(&:downcase)
  !(@my_email_addresses - rcpt_addresses).empty?
end

def path_to_maildir account
  File.join @mailboxes_dir, account, "Maildir"
end

@dovecot_accounts = {}

def load_dovecot_users
  return unless @dovecot_users_file

  if File.exists? @dovecot_users_file
    File.readlines(@dovecot_users_file).each do |line|
      line = line.chomp.sub(/\s#.*/, "")
      if line =~ /^([^\s#:]+):.+user=([^\s@]+)@/
        login_name, new_name = $1.downcase, $2.downcase
        if @dovecot_accounts.key? login_name
          $stderr.puts "WARNING: Duplicate login names in #{@dovecot_users_file}: #{login_name}"
        end
        if login_name != new_name
          @dovecot_accounts[login_name] = new_name
        end
      end
    end
  else
    $stderr.puts "ERROR: Dovecot users file not found: #{@dovecot_users_file}"
    exit 2
  end
end

# resolve to the same account synonyms
def get_account_name email_addr
  account, other = email_addr.split '@'
  account.downcase! # Dovecot also does the same
  if @dovecot_accounts.key? account
    account = @dovecot_accounts[account]
  end
  account
end

def create_mail_to addr
  Mail.new to: addr, from: @my_email_addresses.first
end

def send_howto_message vac

  mail = create_mail_to vac.account_email
  mail.subject = 'Vacation Autoresponder HOWTO'

  mail.body = "Your message does not contain valid activation or cancelation instructions."
  mail.body << "Therefore this very HOWTO is sent to you.\n\n" 
  mail.body << Vacation.howto

  mail.deliver!
end

def notify_vacation_autoresponder_installed vac

  mail = create_mail_to vac.account_email
  mail.subject = 'Vacation Autoresponder activated'

  mail.body = "Vacation Autoresponder accepted for the user #{vac.account_name}\n"
  mail.body << "autoresponder will be activated on: #{vac.activated_at}"
  mail.body << " and deactivated on: #{vac.deactivated_at}"

  mail.deliver!
end

def notify_vacation_autoresponder_canceled vac
  mail = create_mail_to vac.account_email
  mail.subject = 'Vacation Autoresponder canceled'

  mail.body = "Vacation Autoresponder will be deactivated for the user #{vac.account_name} shortly"

  mail.deliver!
end

######################################################################

service = "vacation"
service_maildir_path = path_to_maildir service

@our_domains = ["linguistics.rub.de", "linguistics.ruhr-uni-bochum.de"]
@my_email_addresses = @our_domains.map { |dmn| "#{service}@#{dmn}" }

unless File.directory? service_maildir_path
  $stderr.puts "ERROR: Maildir not found: #{service_maildir_path}"
  exit 1
end

load_dovecot_users

vacations = Hash.new{ |h,k| h[k] = [] }

service_maildir = Maildir.new service_maildir_path, false

[:cur, :new].each do |loc|
  service_maildir.list(loc).each do |mailfile|

    if @debug
      puts "\n\n=== Processing Email ==="
      puts mailfile.path
    end

    msg = Mail.read(mailfile.path)

    unless mail_to_me? msg
      puts "Not a mail to me"
      next
    end

    senders = senders_in_our_domain(msg)

    if senders.empty?
      puts "Sender not in our domain: #{msg.from}"
      next
    end

    if msg.multipart?
      msg_body = msg.text_part || msg.html_part
    else
      msg_body = msg.body
    end

    vac = Vacation.new msg_body.decoded

    # TODO: in theory, there can be several addresses in the From
    # field and consequently in the senders array. But we ignore
    # this situation for the moment.

    # Keep the original sender address to be able to send a notice
    # back to the user.
    vac.account_email = senders.first

    # Store account name that will be used for:
    # - computing the path to the mailbox
    # - identifying vacation emails belonging to the same user
    vac.account_name = get_account_name(vac.account_email)

    # Set date on which request date was received.
    # Necessary for finding out the vacation request that is most
    # up-to-date and needs to be reacted.
    vac.requested_at = msg.date

    # Attach original email file, we may want to manipulate it
    vac.email_file = mailfile

    if @debug
      puts "=== Vacation object ==="
      #puts vac.inspect
      puts vac.to_s
    end

    vacations [vac.account_name] << vac
  end
end

vacations.each do |account, vacs|
  puts "\n### #{vacs.length} vacation request(s) from account: #{account}"

  # sort messages from a single account in descending order
  # so that the most recent message comes first
  vacs.sort_by!{ |vac| vac.requested_at }.reverse!
  
  howto_message_sent = false
  ignore_remaining_requests = false

  vacs.each do |vac|
    if ignore_remaining_requests
      # skip

    elsif vac.valid_request?

      if vac.canceled?
        # TODO: remove autoresponder
        notify_vacation_autoresponder_installed vac
      else
        # TODO: install autoresponder
        notify_vacation_autoresponder_canceled vac
      end

      ignore_remaining_requests = true

    elsif ! howto_message_sent
      send_howto_message vac
      howto_message_sent = true

    end

    # TODO: delete this message
  end
end

# methods of Maildir object
#[:dir, :unique_name, :info, :serializer, :write, :process, :info=, :passed?, :passed!, :replied?, :replied!, :seen?, :seen!, :trashed?, :trashed!, :draft?, :draft!, :flagged?, :flagged!, :flags, :flags=, :add_flag, :remove_flag, :filename, :key, :path, :data, :utime, :atime, :mtime, :destroy, :guard, :parse_key, :sort_flags, :old_path, :rename, :between?]

# methods of Mail object

#[:[], :[]=, :action, :add_charset, :add_content_transfer_encoding, :add_content_type, :add_date, :add_file, :add_message_id, :add_mime_version, :add_part, :add_transfer_encoding, :all_parts, :atom_safe?, :attachment, :attachment?, :attachments, :bcc, :bcc=, :bcc_addrs, :body, :body=, :body_encoding, :body_encoding=, :bounced?, :boundary, :bracket, :capitalize_field, :cc, :cc=, :cc_addrs, :charset, :charset=, :comments, :comments=, :constantize, :content_description, :content_description=, :content_disposition, :content_disposition=, :content_id, :content_id=, :content_location, :content_location=, :content_transfer_encoding, :content_transfer_encoding=, :content_type, :content_type=, :content_type_parameters, :convert_to_multipart, :dasherize, :date, :date=, :decode_body, :decoded, :default, :deliver, :deliver!, :delivery_handler, :delivery_handler=, :delivery_method, :delivery_status_part, :delivery_status_report?, :destinations, :diagnostic_code, :dquote, :encode!, :encoded, :envelope_date, :envelope_from, :error_status, :errors, :escape_paren, :filename, :final_recipient, :find_first_mime_type, :from, :from=, :from_addrs, :has_attachments?, :has_charset?, :has_content_transfer_encoding?, :has_content_type?, :has_date?, :has_message_id?, :has_mime_version?, :has_transfer_encoding?, :header, :header=, :header_fields, :headers, :html_part, :html_part=, :in_reply_to, :in_reply_to=, :inform_interceptors, :inform_observers, :is_marked_for_delete?, :keywords, :keywords=, :main_type, :map_lines, :map_with_index, :mark_for_delete=, :match_to_s, :message_content_type, :message_id, :message_id=, :method_missing, :mime_parameters, :mime_type, :mime_version, :mime_version=, :multipart?, :multipart_report?, :paren, :part, :parts, :perform_deliveries, :perform_deliveries=, :quote_atom, :quote_phrase, :quote_token, :raise_delivery_errors, :raise_delivery_errors=, :raw_envelope, :raw_source, :read, :ready_to_send!, :received, :received=, :references, :references=, :register_for_delivery_notification, :remote_mta, :reply, :reply_to, :reply_to=, :resent_bcc, :resent_bcc=, :resent_cc, :resent_cc=, :resent_date, :resent_date=, :resent_from, :resent_from=, :resent_message_id, :resent_message_id=, :resent_sender, :resent_sender=, :resent_to, :resent_to=, :retryable?, :return_path, :return_path=, :sender, :sender=, :set_envelope, :skip_deletion, :smtp_envelope_from, :smtp_envelope_from=, :smtp_envelope_to, :smtp_envelope_to=, :sub_type, :subject, :subject=, :text?, :text_part, :text_part=, :to, :to=, :to_addrs, :token_safe?, :transfer_encoding, :transport_encoding, :transport_encoding=, :unbracket, :underscoreize, :unparen, :unquote, :uri_escape, :uri_parser, :uri_unescape, :without_attachments!]


