#!/usr/bin/env ruby

# # #
# > gem install maildir mail
#  https://github.com/ktheory/maildir
#  https://github.com/mikel/mail
#
# TODO: move all messages into templates (slim? haml?)
# TODO: make dates more human-friendly in notifications that are
#       sent
# TODO: add logging mechanism
# TODO: how to treat mail coming from illegal users
#       (users from different domains)? Delete?
#       - Now they are ignored and remain in the mailbox
# TODO: update Vacation.howto
# TODO: wrap main logic into VacationAutoresponder class?
# TODO: make it into a gem?
#
# DONE: avoid processing autoreplies coming to vacation account.
#       Implemented by avoiding generating autoreplies to
#       vacation account.
#       Add this to HOWTO
# DONE: never install vacation autoresponder to vacation account
#       It is hardly possible that such request will be sent but
#       it is good to be on a safe side.
#       Add this to HOWTO
# DONE: add --test-mode that installs autoresponder
#       only for specific users and only with specific sender addresses
#       - that can be defined in vacation_autoresponder.conf
#       ? TODO and also via the command line?
#       ? TODO should these limitations be also in vacations.yaml?
#
# Examples to try:
# manage_vacation --show-sieve-script 
#                 --from=talpus@gmail.com,tux@linguistics.rub.de
#                 --conf path/to/configuration_file
#

require 'maildir'
require 'mail'

require 'yaml'
require 'time'
require 'optparse'

######################################################################
# extensions to core classes (just for fun)

class Hash
  def symbolize_keys
    each_with_object({}) do |(k,v), hash|
      if v.is_a? Hash
       v = v.symbolize_keys
      end
      hash[k.to_sym] = v
    end
  end
end

class Fixnum

  # expressed in seconds
  def hours
    self * 60 * 60
  end
  alias hour hours

  # expressed in minutes
  def minutes
    self * 60
  end
  alias minute minutes

  # expressed in seconds
  def days
    self * 24.hours
  end
  alias day days
end

class Time
  def in_the_past?
    self < Time.now
  end

  def in_the_future?
    self > Time.now
  end
end

######################################################################

class Conf
  @@keep_messages  = false
  @@test_mode      = false
  @@test_accounts  = nil
  @@account_emails = {}
  @@account_groups = nil

  class << self
    def method_missing meth, *args
      @@config[meth.to_sym]
    end

    def service_email_addresses
      @@service_email_addresses ||= email_addresses_of service_account_name
    end

    def email_addresses_of account
      unless @@account_emails.key? account
        accounts = [ account ]
        if Conf.autoreply_if_received_to_group_alias
          load_virtual_alias_maps
          accounts.concat @@account_groups[account] || []
        end
        @@account_emails[account] = accounts.map do |acc|
          domains.map do |domain|
            [acc, domain].join("@")
          end
        end.flatten
      end

      @@account_emails[account]
    end

    def file= path
      @@config = YAML.load_file(path).symbolize_keys
    end

    def from_service
      "#{@@config[:service_name]} <#{@@config[:service_email]}>"
    end

    def test_mode_on
      @@test_mode = true
    end

    def test_mode_on?
      @@test_mode
    end

    def keep_messages= val
      @@keep_messages = val
    end

    def keep_messages?
      @@keep_messages
    end

    # USAGE: use this method with Conf.test_mode_on? only
    def test_accounts
      if test_mode_on?
        @@test_accounts ||= Conf.test.map do |v|
          v.is_a?(Hash) ? v.keys : v
        end.flatten
      end
      @@test_accounts || []
    end

    # return list of sender emails for which given test account
    # wants to activate autoresponder
    # USAGE: use this method with Conf.test_mode_on? only
    def senders_for_test_account account
      senders = []
      if test_mode_on?
        Conf.test.each do |v|
          if v.is_a?(Hash) && v.keys.include?(account)
            senders.concat v[account]
          end
        end
      end
      senders.empty? ? nil : senders
    end

    # TODO: maybe somewhere under /var/ ?
    def vacations_file
      File.join mailboxes_dir, 
                @@config[:service_account_name], # vacation
                @@config[:vacations_file]        # vacations.yml
    end

    def mail_home account
      File.join mailboxes_dir, account
    end

    def mail_dir account
      File.join mail_home(account), @@config[:mail_dir] # "Maildir"
    end

    def service_mail_dir
      mail_dir @@config[:service_account_name]
    end

    def sieve_dir account
      File.join mail_home(account), @@config[:sieve_dir] # "sieve"
    end

    def sieve_vacation_file account
      File.join sieve_dir(account), @@config[:sieve_vacation_file] # "vacation.sieve"
    end

    def sieve_main_file account
      File.join sieve_dir(account), @@config[:sieve_main_file] # "main.sieve"
    end

    def sieve_active_file account
      File.join mail_home(account), @@config[:sieve_active_file] # .dovecot.sieve
    end

    def load_virtual_alias_maps
      return  if @@account_groups

      fname = @@config[:virtual_alias_maps_file]
      unless File.exists? fname
        raise "File not found: #{fname}"
      end

      @@account_groups = {}

      grpname = nil
      File.open(fname).each do |line|
        line.sub! /\s+#.+$/, ""
        line.downcase!

        next  if line =~ /^#/

        if line =~ /^(\S+)(\s.*)/
          lhs, line = $1.strip, $2
          name, domain = lhs.split '@'
          grpname = domains.include?(domain) ? name : nil
        end

        if grpname && line =~ /\s+(.+)/
          rhs = $1
          rhs.strip.downcase.split(/[\s,;]+/).each do |addr|
            name, domain = addr.split '@'
            if domains.include? domain
              (@@account_groups[name] ||= []) << grpname
            end
          end
        end
      end
    end
  end
end

######################################################################

class Mailer
  class << self

    def send_mail other_params
      params = { from: Conf.from_service }.merge(other_params)
      mail = Mail.new params
      mail.deliver!
    end

    def send_howto_message vac
      include_state = true

      msg = "Dear User,"

      msg << "\n\nYour message does not contain valid Vacation Autoresponder activation or cancelation instructions."

      msg << "\nThe following errors were encountered:"
      vac.errors.each_with_index do |err, i|
        msg << "\n #{i+1}) #{err}"
      end

      if include_state
        msg << "\n\n### Current state of Vacation Autoresponder\n\n"

        # TODO: a better way to access already installed Vacation
        # for the current user?
        existing_vac = VacationsFile.vacations[vac.account_name]

        if existing_vac
          if existing_vac.activated?
            msg << "There is an autoresponder already active for your account that will be "
          else
            msg << "An autoresponder will be activated on #{existing_vac.activated_at} and "
          end

          msg << "deactivated on #{existing_vac.deactivated_at}."
          msg << "\nThe following message is sent:"
          msg << "\n{Beginning of message}\n"
          msg << existing_vac.message
          msg << "\n{End of message}"

        else
          msg << "There have been no requests for Vacation Autoresponder from your account"
        end

      end

      msg << "\n\n### HOWTO\n\n"
      msg << Vacation.howto

      params = {
        to:       vac.account_email,
        subject: 'Vacation Autoresponder HOWTO',
        body:     msg
      }

      send_mail params
    end

    def notify_vacation_autoresponder_accepted vac

      msg = "Vacation Autoresponder request accepted for the user"
      msg << " #{vac.account_name}\n"
      msg << "autoresponder will be activated on: #{vac.activated_at}"
      msg << " and deactivated on: #{vac.deactivated_at}"
      msg << "\nThe following message will be sent:"
      msg << "\n{Beginning of message}\n"
      msg << vac.message
      msg << "\n{End of message}"

      params = {
        to:       vac.account_email,
        subject: 'Vacation Activation request accepted',
        body:     msg
      }

      send_mail params
    end

    def notify_vacation_autoresponder_canceled vac
      msg = "Dear User,"
      msg << "\n\nVacation Autoresponder will be deactivated for you shortly."

      params = {
        to:       vac.account_email,
        subject: 'Vacation Cancelation request accepted',
        body:     msg
      }

      send_mail params
    end

    def notify_vacation_autoresponder_activated vac

      msg = "Dear user,"
      msg << "\n\nVacation autoresponder has just been activated for you. "
      msg << "The following message will be sent:"
      msg << "\n{Beginning of message}\n"
      msg << vac.message
      msg << "\n{End of message}"
      msg << "\nVacation autoresponder will be deactivated on #{vac.deactivated_at}"

      params = {
        to:       vac.account_email,
        subject: 'Vacation Autoresponder activated',
        body:     msg
      }

      send_mail params
    end

    def notify_vacation_autoresponder_deactivated vac
      msg = "Dear user,"
      msg << "\n\nVacation autoresponder has just been deactivated."

      params = {
        to:       vac.account_email,
        subject: 'Vacation Autoresponder deactivated',
        body:     msg
      }

      send_mail params
    end

    def notify_vacation_autoresponder_not_found vac
      msg = "Dear User,"
      msg << "\n\nNo active Vacation Autoresponder was found for your account."

      params = {
        to:       vac.account_email,
        subject: 'Vacation Autoresponder not active',
        body:     msg
      }

      send_mail params
    end
  end
end

######################################################################

class SieveScript
  class << self

    def main
      lines = []
      lines << 'require ["include"];'
      lines << 'include :personal "vacation";'
      lines.join("\n")
    end

    # checks that main.sieve contains necessary lines
    # see #main for details
    def insert_vacation! lines

      changed = false
      has_require_include = false
      has_include_vacation = false

      lines.map! do |line|
        line.chomp!

        # Ensure that 'include' library is imported
        if line =~ /^require/ && !has_require_include
          if line !~ /['"]include['"]/
            line.sub!(/\]/, ", \"include\"]")
            changed = true
          end
          has_require_include = true
        end

        # check that vacation is included
        if line =~ /include\s+:personal\s+['"]vacation['"]/
          has_include_vacation = true
        end

        line
      end

      unless has_require_include
        lines.unshift "require [\"include\"];"
        changed = true
      end

      unless has_include_vacation
        lines.push 'include :personal "vacation";'
        changed = true
      end

      changed
    end

    def activate_vacation! lines
      changed = false

      lines.map! do |line|
        line.chomp!
        if line =~ /include\s+:personal\s+['"]vacation['"]/ && line =~ /^#/
          line.sub! /^#.*include/, "include"  # uncomment the line
          changed = true
        end
        line
      end

      changed
    end

    def deactivate_vacation! lines
      changed = false

      lines.map! do |line|
        line.chomp!
        if line =~ /include\s+:personal\s+['"]vacation['"]/ && line !~ /^#/
          line = "#" + line  # comment the line
          changed = true
        end
        line
      end

      changed
    end

    def vacation args=nil

      lines = []
      lines << "# This file is generated by the script #{$0}"
      lines << "# DO NOT EDIT. Chances are your changes will be overriden."
      lines << ""
      lines << 'require ["variables", "vacation", "fileinfo"];'
      lines << ""

      # Do not autoreply to spam
      lines << 'if header :contains "X-Spam-Flag" "YES" { stop; }'
      lines << ""

      # set variable <originalSubject>
      lines << 'if header :matches "Subject" "*" { set "originalSubject" ": ${1}"; }'
      lines << ""

      # We do not want to auto-reply to the messages that activated
      # Autoresponder sends us.
      from = header_from Conf.service_email_addresses
      lines << "if anyof (#{from}) { keep; }\n"

      #
      # vacation rule
      #
      if args.key? :from
        lines << "elsif anyof (#{header_from(args[:from])}) {"
      else
        lines << "else {"
      end

      subject = '[Autoreply] Out of office\${originalSubject}'

      lines << "vacation"
      #lines << "  :days 1" # use default value from Dovecot config
      lines << "         :subject \"#{subject}\""
      if args.key? :addresses
        addresses = args[:addresses].map{ |addr| "\"#{addr}\"" }.join(", ")
        lines << "         :addresses [#{addresses}]"
      end
      lines << "         text:\n#{args[:text]}\n.\n;\n}"

      lines.join("\n")
    end

    def header_from addr
      if addr.respond_to? :map
        addr.map{ |item| header_from item }.join(", ")
      else
        "header :contains \"from\" \"#{addr}\""
      end
    end
  end
end

######################################################################
# class for managing vacations.yaml
#
# read the file
# get a single entry as Vacation object

class VacationsFile
  attr_reader :data

  def self.example
    Vacation.example_entry_for_config.to_yaml
  end

  # TODO: a better solution?
  def self.vacations
    @@vacations ||= {}
  end

  def initialize filename
    @filepath = filename

    if File.exists? @filepath
      @data = YAML.load_file @filepath

      @data.each do |account_name, entry|
        vac = Vacation.new entry
        vac.account_name = account_name
        @data[account_name] = vac
      end

      # delete example entry
      @data.delete_if{ |k,v| v.example? }

      # paranoic mode on:
      # ignore service account of Autoresponder. There is no legal
      # scenario how it could have gotten into vacations_file but...
      @data.delete_if{ |k,v| v.account_name == Conf.service_account_name }

      # when in test mode, pick only those entries from the vacations file
      # that correspond to accounts of interest
      if Conf.test_mode_on?
        @data.select!{ |k,v| Conf.test_accounts.include?(v.account_name) }
      end

    else
      @data = Hash.new
    end

    @@vacations = self
  end

  def method_missing meth, *args
    @data.send meth, *args
  end

  def save
    data = {}

    # add the example entry, always at the beginning
    data.merge! Vacation.example_entry_for_config

    # add real entries, except those that have been canceled/deactivated
    # NOTE: in test mode, accounts other that those specified as test
    # accounts will get lost
    @data.values.each do |vac|
      data.merge!(vac.for_config)  unless vac.canceled?
    end

    File.open(@filepath, "w+") do |file|
      YAML.dump data, file
    end
  end
  alias close save

  def add vac
    if vac.is_a? Array
      vac.each{ |v| add v }
    elsif vac.is_a? Vacation
      @data[vac.account_name] = vac
    end
  end

  def each
    @data.each do |account, vacation|
      yield vacation
    end
  end
end

######################################################################

class Vacation
  attr_reader   :starts_at, :ends_at
  attr_reader   :activated_at, :deactivated_at
  attr_accessor :requested_at
  attr_accessor :account_name, :account_email
  attr_accessor :email_file
  attr_reader   :errors

  attr_accessor :closed

  def self.howto
    # TODO: get rid of this hardcode. Note Conf.service_email_addresses
    # may not be yet accessible at this point.
    # TODO: the HOWTO contains my hardcoded addresses
    service_email    = "vacation@linguistics.rub.de"
    postmaster_email = "postmaster@linguistics.rub.de"

    outs = []

    outs << "
## SYNOPSYS

The purpose of this service is to allow users to activate/deactivate Vacation
Autoresponder for their own email account.

Interaction with the service is carried out by sending emails to the special
address that is specified in the configuration file, typically:

   #{service_email}

The email should contain Autoresponder activation or deactivation instructions
as described further in this document. If the email is not recognized as a valid
request, this very HOWTO is sent in reply.

There is a delay between the time when the email arrives and when the email is
processed, depending on how corresponding cron job is configured. Be patient.

Plain text emails are preferred. Html emails were not tested. Configure your
mailer to include plain text when sending to this account

## HOW TO ACTIVATE AUTORESPONDER

To activate the Autoresponder, the user should send an email containing
at least two dates: the date when the vacation starts and ends. The dates
should be given in the format DD.MM.YYYY (e.g. 31.12.2015). The following
is an example of such a request email:

   first day: 20.12.2015
   last day: 14.01.2016

Please note that the dates should be given on separate lines and the colon
is obligatory.

In addition, there is a possibility to specify a message that will be sent
in the automatic reply. The message is introduced by the keyword 'message'
followed by a colon and desired text.

   message: I am on vacation.

The message text can span over various lines:

   message: Dear Friend,
   I am on vacation and therefore can not answer your email immediately.
   Please excuse. Better, try finding the answer to your question yourself.
   Sincerely yours,
   Sinsere Lee Yohrs

If no message is specified, the default one will be sent:

   #{self.new.message_default}

Optionally, the instructions for the Autoresponder Service can be ended
with the special keyword '=end'. The use of the end-keyword allows combining
in a single email both the conventional email to human recipients and
the instructions to the Autoresponder Service. For example, the following
is a valid example:

   Dear Colleagues,

   I am leaving on vacation soon. In addition to the common X-mas vacation,
   I am taking a few extra days. For urgent issues, please contact 112.

   first day: 20.12.2015                                          **
   last day: 14.01.2016                                           **
   message: Hi! I am on X-mas vacation enjoying skiing in Alps    **
   Hope you also enjoy this merry period.                         **
   =end

   Have nice holidays too.
   Best regards,
   Sinsere Lee Yohrs

In the above example, only the lines marked with ** will be used by
the Autoresponder. Without =end keyword, the message will be the full
chunk of text starting form message: and upto the end of the email.

By default the Autoresponder is activated at 18:00 on the day *before*
the vacation starts as specified by 'first day' keyword. If the scheduled
day of activation happens to be Saturday or Sunday, it is shifted back
further to Friday, 18:00.

There is only one possibility to override the default activation time,
namely by including 'activate: now' stanza. For example

   first day: 20.12.2015
   last day: 14.01.2016
   activate: now
   message: ....

The Autoresponder will become effective as soon as the request is processed.

## HOW TO DEACTIVATE AUTORESPONDER

Deactivation of the Autoresponder Service happens automatically on the date
that was specified as the last day of the vacation, more precisely at 18:00.

However, the Autoresponder can be deactivated at any time by sending an email
containing the word

  cancel

## NOTIFICATIONS

The Service sends a number of (sometimes annoying) notifications. However,
the lack of appropriate notification can be a signal of a problem, therefore,
please be patient and report a problem to #{postmaster_email}.

1. Vacation Activation request accepted

  The notification is sent shortly after the user has sent a valid request
  to the service email.
  If the request is not valid, the HOWTO message is sent instead.

2. Vacation Cancelation request accepted

  This notification is sent shortly after the user has sent cancelation request.
  If the request is not valid, a HOWTO message is sent instead.

3. Vacation Autoresponder activated

  This notification is sent after the autoresponder has become effective.

4. Vacation Autoresponder deactivated

  This notification is sent after the autoresponder has been switched off.

5. Vacation Autoresponder HOWTO

  This notification is sent if the user sends an empty email or any other
  email that is not a valid Vacation Activation/Cancelation request.

  This notification additionally includes information on the current state
  of the Vacation Autoresponder for the user account.

## GORY DETAILS (DEVS AND ADMINS ONLY)

TODO:

- How to install the service
- How emails are filtered to avoid unauthorized use
- How it works with mailing lists - correctly ignores
- How it works with group emails - not implemented yet, planned: should
  respond to the sender (only).

## BUG REPORTS

Send bugreports and suggestions for improvement to:

   Mikalai Krot <talpus@gmail.com> or <krot@linguistics.rub.de>

"
    outs.join("\n")
  end

  def self.example_entry_for_config
    obj = self.new

    obj.account_name  = "johnsmith"
    obj.account_email = "john.smith@example.com"
    obj.starts_at     = "13.1.2016"
    obj.ends_at       = "29.1.2016"
    obj.message       = "Example: I am on vacation from #{obj.starts_at} till #{obj.ends_at}."

    obj.for_config
  end

  def initialize obj=nil
    @closed           = false
    @parsing_message  = false
    @deleted          = false
    @activated        = false
    @fake             = false
    @debug            = false
    @errors           = []
    @frozen_variables = {}

    if ! obj
      # skip
    elsif obj.is_a? String
      parse_text obj
    elsif obj.is_a? Hash
      parse_hash obj
    elsif obj.is_a? self.class
      # TODO: make a deep copy. will do it when needed :)
    else
      raise "ERROR: Invalid data type #{obj.class} of:\n#{obj}"
    end

  end

  def parse_hash hash
    self.account_email  = hash["email"]
    self.activated_at   = hash["activation_time"]
    self.deactivated_at = hash["deactivation_time"]
    self.message        = hash["message"]
    self.activated      = hash["activated"]

    @fake = self.account_email == "john.smith@example.com"
  end

  # TODO: test if works with html
  def parse_text text

    if @debug
      puts "=== parsing text to find Vacation ==="
      puts text
    end

    text.split(/\n/).each do |line|
      line.chomp!
      line.strip!
      if line =~ /^=vacation/i
        reset_parsed
      elsif line =~ /=end/i
        @closed = true
        break
      elsif line =~ /^(cancel|deactivate)/i
        cancel
      elsif line =~ /^activate:\s*(now|jetzt)/i
        self.activated_at = Time.now - 1, freeze=true
      elsif line =~ /^(?:first|start) (?:day|date):(.+)/i
        self.starts_at = $1
      elsif line =~ /^(?:last|end) (?:day|date):(.+)/i
        self.ends_at = $1
      elsif line =~ /^message:(.*)/i
        @message = $1.strip
        @parsing_message = true
      elsif parsing_message?
        @message << "\n" << line
      end
    end

    validate
  end

  def reset_parsed
    @starts_at = @ends_at = nil
    @message = nil
    @parsing_message = false
  end

  def starts_at= val
    @parsing_message = false
    @starts_at = val.is_a?(Date) ? val : Date.parse(val)

    # Set Autoresponder activation time at 18:00 of the day
    # before user vacation starts.
    # If it happens to be on weekend, move it further to Friday
    # NOTE: this is described in Vacation.howto, keep in sync
    activated_at = @starts_at.to_time - 6.hours
    if activated_at.sunday?
      activated_at -= 2.days
    elsif activated_at.saturday?
      activated_at -= 1.day
    end
    # Anyway, activation time far in the past does not make sense
    if activated_at.in_the_past?
      activated_at = Time.now - 1
    end

    self.activated_at = activated_at

    @starts_at
  end

  def ends_at= val
    @parsing_message = false
    @ends_at = val.is_a?(Date) ? val : Date.parse(val)

    # set Autoresponder deactivation time at 18:00 of the last
    # day of the user's vacation
    # NOTE: described in Vacation.howto, keep in sync
    @deactivated_at = @ends_at.to_time + 18.hours
    # we can not travel to the past, instead fix time to be now
    # if it happens to be in the past
    if @deactivated_at.in_the_past?
      @deactivated_at = Time.now - 1
    end

    @ends_at
  end

  def activated_at= val
    if val.is_a? Array
      # handling case when the method was called as:
      #  obj.activated_at = Time.now, freeze=true
      val, freeze = val
    end
    if can_change? :activated_at
      @activated_at = to_time val
    end
    if freeze
      disallow_changing :activated_at
    end
    @activated_at
  end

  def deactivated_at= val
    @deactivated_at = to_time val
  end

  def message?
    !@message.to_s.empty?
  end

  def message= str
    @message = str.dup
  end

  def message
    @message || message_default
  end

  def message_default
    "I am on vacation from #{starts_at || '<NoDate>'} through #{ends_at || '<NoDate>'}."
  end

  def parsing_message?
    @parsing_message
  end

  def cancel
    @canceled = true
    @deactivated_at = Time.now - 1
  end

  def canceled?
    @canceled
  end

  def activated?
    @activated
  end

  def activate
    @activated = true
  end

  def valid_request?
    @errors.empty?
  end

  def example?
    @fake
  end
  alias fake? example?

  def to_s
    out = []
    out << "account: #{account_name}"
    out << "email: #{account_email}"
    if canceled?
      out << "vacation: canceled"
      out << "deactivated_at: #{deactivated_at}"
    else
      out << "from: #{starts_at}"
      out << "till: #{ends_at}"
      out << "message:\n#{message}\nend_of_message"
      out << "*requested at: #{requested_at}"
      out << "*activated: #{activated?}"
      out << "*activated_at: #{activated_at}"
      out << "*deactivated_at: #{deactivated_at}"
      out << "*email path: #{email_file ? email_file.path : nil}"
    end
    out.join("\n")
  end

  # TODO: ugly. maybe move converter to VacationsFile?
  # after all, activation_time is VacationFile speak
  def for_config
    #.iso8601               #=> 2015-11-13T18:00:00+01:00
    fmt = "%F %T %z"        #=> 2015-11-25 18:00:00 +0100
    #fmt = "%d.%m.%Y %T %z" #=> 13.11.2015 18:00:00 +0100
    #puts deactivated_at.strftime(fmt)

    {
      account_name => {
        "email"             => account_email,
        "activated"         => activated?,
        "activation_time"   => activated_at   ?
                                 activated_at.strftime(fmt)   : nil,
        "deactivation_time" => deactivated_at ?
                                 deactivated_at.strftime(fmt) : nil,
        "message"           => message? ? message : nil
      }
    }
  end

  private

  def activated= val
    @activated = to_boolean val
  end

  def to_boolean val
    ["yes", "true"].include?(val.to_s.downcase)
  end

  def can_change? varname
    ! @frozen_variables.key?(varname)
  end

  def disallow_changing varname
    @frozen_variables[varname] = true
  end

  def closed= v
    @closed = v
    @parsing_message = false  if @closed
  end

  def validate
    if canceled?
      # all is fine, nothing to check

    else
      # check dates specified by the user
      if self.starts_at && self.ends_at

        if self.ends_at < self.starts_at
          @errors << "Vacation last day can not be before the first day"
        elsif self.ends_at < Date.today
          @error << "Vacation last day can not be in the past"
        end

      else
        unless self.starts_at
          @errors << "Request must specify the first day of vacation"
        end
        unless self.ends_at
          @errors << "Request must specify the last day of vacation"
        end
      end
    end
  end

  def to_time val
    val.is_a?(Time) ? val : Time.parse(val)
  end
end

# testing if can disallow re-setting activated_at field
#v = Vacation.new
#v.activated_at = Time.now, true
#v.starts_at = (Time.now + 1.day).to_date
#puts v.to_s

######################################################################

class EmailAnalyser
  attr_accessor :debug

  def initialize
    self.maildir_path = Conf.service_mail_dir
    @maildir = nil
    @vacations = []

    @debug = false
  end

  def my_domains
    @my_domains ||= Conf.domains.dup
  end

  def maildir
    @maildir ||= Maildir.new @maildir_path, false
  end

  def vacations
    @vacations.dup
  end

  def process_emails
    parse_emails
    analyse_vacations
    @vacations
  end

  private

  def parse_emails
    @vacations_from_emails = Hash.new{ |h,k| h[k] = [] }

    [:cur, :new].each do |loc|
      maildir.list(loc).each do |mailfile|

        if @debug
          puts "\n\n=== Processing Email ==="
          puts mailfile.path
        end

        msg = Mail.read mailfile.path

        unless mail_to_me? msg
#          puts "Not a mail to me"
          next
        end

        # TODO: disregard emails that are autoreplies

        senders = senders_in_my_domain(msg)

        # paranoic mode on:
        # ignore vacation requests coming from Vacation Autoresponder
        # service. This situation is unreal but... paranoia
        senders -= Conf.service_email_addresses

        if senders.empty?
#          puts "Sender not in our domain: #{msg.from}"
          next
        end

        unless known_email? senders.first
#          puts "User email unknown: #{senders.first}"
          next
        end

        if Conf.test_mode_on? &&
           ! Conf.test_accounts.include?(get_account_name(senders.first))
        then
#          puts "[TESTMODE] Ignoring sender #{senders.first} that is not in test accounts"
          next
        end

        if msg.multipart?
          msg_body = msg.text_part || msg.html_part
        else
          msg_body = msg.body
        end

        vac = Vacation.new msg_body.decoded

        # TODO: in theory, there can be several addresses in the From
        # field and consequently in the senders array. But we ignore
        # this situation for the moment.

        # Keep the original sender address to be able to send a notice
        # back to the user.
        vac.account_email = senders.first

        # Store account name that will be used for:
        # - computing the path to the mailbox
        # - identifying vacation emails belonging to the same user
        vac.account_name = get_account_name(vac.account_email)

        # Set date on which request date was received.
        # Necessary for finding out the vacation request that is most
        # up-to-date and needs to be reacted.
        vac.requested_at = msg.date

        # Attach original email file, we may want to manipulate it
        vac.email_file = mailfile

        if @debug
          puts "=== Vacation object ==="
          #puts vac.inspect
          puts vac.to_s
        end

        @vacations_from_emails [vac.account_name] << vac
      end
    end
  end

  def analyse_vacations
    @vacations = []

    @vacations_from_emails.each do |account, vacs|
      if @debug
        puts "\n### #{vacs.length} vacation request(s) from account: #{account}"
      end

      # sort messages from a single account in descending order
      # so that the most recent message comes first
      vacs.sort_by!{ |vac| vac.requested_at }.reverse!

      howto_message_sent = false
      ignore_remaining_requests = false

      vacs.each do |vac|
        if @debug
          puts "== Vacation request user #{account}"
          puts vac.to_s
          puts "= yaml ="
          puts vac.for_config.to_yaml
          puts "\n"
        end

        if ignore_remaining_requests
          # skip

        elsif vac.valid_request?

          @vacations << vac
          ignore_remaining_requests = true

          if vac.canceled?
            # TODO: cancelation happens immediately
            # perhaps there is no need to send this email to avoid
            # annoying the users with two emails
            Mailer.notify_vacation_autoresponder_canceled vac
          else
            Mailer.notify_vacation_autoresponder_accepted vac
          end

        elsif ! howto_message_sent
          # send HOWTO message if the user sent us an incorrect request,
          # but do it only once
          Mailer.send_howto_message vac
          howto_message_sent = true

        end

        # delete this message from the mailbox
        # we dont want to process it next time the script is run
        unless Conf.keep_messages?
          # vac.email_file.add_flag("T") # does not delete but merely marks as Trashed
          vac.email_file.destroy
        end
      end
    end
  end

  def maildir_path= path
    if File.directory? path
      @maildir_path = path
    else
      $stderr.puts "ERROR: Maildir not found: #{path}"
      exit 1
    end
  end

  def senders_in_my_domain msg
    # as per RFC, the From field can contain several addresses
    from = msg.from || []
    senders = from.select do |addr|
      username, domain, other = addr.split '@'
      my_domains.include?(domain.downcase)
    end
    senders
  end

  def mail_to_me? msg
    rcpt_addresses = [:to, :cc].map do |meth|
      msg.send(meth)
    end.flatten.compact.map(&:downcase)
    ! (Conf.service_email_addresses - rcpt_addresses).empty?
  end

  def dovecot_accounts
    unless @dovecot_accounts
      @dovecot_accounts = {}
      load_dovecot_users
    end
    @dovecot_accounts
  end

  def load_dovecot_users
    return unless Conf.dovecot_users_file

    if File.exists? Conf.dovecot_users_file
      File.readlines(Conf.dovecot_users_file).each do |line|
        line = line.chomp.sub(/\s#.*/, "")
        if line =~ /^([^\s#:]+):.+user=([^\s@]+)@/
          login_name, new_name = $1.downcase, $2.downcase
          if @dovecot_accounts.key? login_name
            $stderr.puts "WARNING: Duplicate login names in #{Conf.dovecot_users_file}: #{login_name}"
          end
          @dovecot_accounts[login_name] = new_name
        end
      end
    else
      $stderr.puts "ERROR: Dovecot users file not found: #{Conf.dovecot_users_file}"
      exit 2
    end
  end

  # resolve to the same account synonyms
  # return nil if the email address is unknown
  def get_account_name email_addr
    account, other = email_addr.split '@'
    dovecot_accounts[account.downcase]
  end

  def known_email? email_addr
    !! get_account_name(email_addr)
  end
end

######################################################################
# other methods

def verboser msg
  if @options[:debug]
    puts msg
  end
end

def create_sieve_environment account
  verboser "Creating Sieve environment for #{account}"

  sieve_dir = Conf.sieve_dir account
  unless Dir.exists? sieve_dir
    Dir.mkdir sieve_dir
  end

  # write main.sieve file or make amendments to already existing file
  sieve_main_file = Conf.sieve_main_file account
  if File.exist? sieve_main_file
    verboser "ensuring that existing #{sieve_main_file} file contains relevant code"
    lines = IO.readlines sieve_main_file
    if SieveScript.insert_vacation! lines
      File.open sieve_main_file, "w+" do |file|
        file.puts lines.join("\n")
      end
    end

  else
    verboser "writing new #{sieve_main_file} file"
    File.open sieve_main_file, "w+" do |file|
      file.puts SieveScript.main
    end
  end

  # Link active sieve script to sieve/main.sieve
  sieve_active_file = Conf.sieve_active_file(account)
  verboser "Symlinking #{sieve_active_file} to #{sieve_main_file}"
  if File.exists? sieve_active_file
    File.delete sieve_active_file
  end
  File.symlink sieve_main_file, sieve_active_file
end

def install_sieve_script vac
  create_sieve_environment vac.account_name

  # write vacation.sieve file
  sieve_vacation_file = Conf.sieve_vacation_file vac.account_name
  verboser "Writing #{sieve_vacation_file} file"
  File.open sieve_vacation_file, "w+" do |file|
    # TODO: handle from: @options[:from_senders] ?
    params = {
      text:      vac.message,
      addresses: Conf.email_addresses_of(vac.account_name)
    }
    if Conf.test_mode_on?
      senders = Conf.senders_for_test_account vac.account_name
      if senders
        params[:from] = senders
      end
    end
    file.puts SieveScript.vacation params
  end

  # amend main.sieve file
  sieve_main_file = Conf.sieve_main_file vac.account_name
  verboser "Activating vacation entry in #{sieve_main_file}"
  lines = IO.readlines sieve_main_file
  if SieveScript.activate_vacation! lines
    File.open sieve_main_file, "w+" do |file|
      file.puts lines.join("\n")
    end
  end
end

def uninstall_sieve_script vac

  # delete vacation.sieve
  sieve_vacation_file = Conf.sieve_vacation_file vac.account_name
  verboser "Deleting #{sieve_vacation_file} file"
  if File.exist? sieve_vacation_file
    File.delete sieve_vacation_file
  end

  #
  # amend main.sieve
  #
  sieve_main_file = Conf.sieve_main_file vac.account_name
  verboser "Deactivating vacation entry in #{sieve_main_file}"

  if File.exist? sieve_main_file
    lines = IO.readlines sieve_main_file

    changed = SieveScript.deactivate_vacation! lines
    if changed
      File.open sieve_main_file, "w+" do |file|
        file.puts lines.join("\n")
      end
    end
  end

end

######################################################################
# process options

@options = {}

OptionParser.new do |opts|
  opts.banner = "
  This script analyses emails coming to special account and
1) generates vacations.yaml file that specifies when vacation autoresponder
   should be de/activated and for which user.
   See --show-vacations-example
2) de/activates vacation autoresponder by un/installing appropriate Sieve
   script in the mail account of appropriate user(s)
Important:
The script should be run either as root or as the same user as Dovecot runs.
The script works with Maildir format only.
Email in plain text is preferred (parsing of html not tested).
USAGE: #{File.basename($0)} [OPTIONS]
OPTIONS:
"

  opts.on('-h', '--help', 'display this message and exit') do
    puts opts
    exit 0
  end

#  @options[:show_howto] = false
  opts.on('--help-request-howto',
          'display HOWTO on how to request/cancel vacation autoresponder') do
#    @options[:show_howto] = true
    puts Vacation.howto
    exit 0
  end

  @options[:conf_file] = File.join ".", 'vacation_autoresponder.conf'
  opts.on('-c FILE', '--conf FILE',
          'path to configuration file (in YAML format)',
          "Default: #{@options[:conf_file]}") do |val|
    @options[:conf_file] = val
  end

  opts.on('--test-mode',
          'run in test mode, limited to a number of account as specified',
          'in the configuration file under `test:\' keyword.',
          'To avoid that test mode destroys valid vacations_file it is',
          'always a good idea to provide a different configuration file.') do
    Conf.test_mode_on
  end

  opts.on('-k', '--keep-messages', 
          'do not deleted messages once they were processed.',
          'This is useful primarily for testing.') do
    Conf.keep_messages = true
  end


  opts.on('--show-vacations-example', 'show example of vacations.yaml') do
    puts Vacation.example_entry_for_config.to_yaml
    exit 0
  end

  @options[:show_sieve_script] = false
  opts.on('--show-sieve-script',
          'show the bolerplate vacation.sieve script that will be installed',
          'In addition, try it with --from option.') do
    @options[:show_sieve_script] = true
  end

  @options[:from_senders] = nil
  opts.on('--from=email1,email2',
          '??? make sieve script active with specified sender addresses only.',
          '??? Especially useful for testing purposes.') do |addresses|
    @options[:from_senders] = addresses.split(",")
  end

  @options[:debug] = false
  opts.on('--debug', 'self explanatory') do
    @options[:debug] = true
  end

  opts.separator " "
end.parse!

Conf.file = @options[:conf_file]

if @options[:show_sieve_script]
  params = {
    text:      'I am on vacation',
    addresses: Conf.email_addresses_of(ENV['USER'])
  }
  if @options[:from_senders]
    params[:from] = @options[:from_senders]
  end
  puts SieveScript.vacation params
  exit 0
end

Mail.defaults do
  delivery_method :smtp, Conf.smtp
end

######################################################################
# MAIN

# load vacation requests from vacations.yaml
vacations = VacationsFile.new Conf.vacations_file

# find new vacation autoresponder requests in the service mailbox
email_analyser       = EmailAnalyser.new
email_analyser.debug = @options[:debug]
email_analyser.process_emails

#puts "vacation requests found in emails from the following users: " +
#     email_analyser.vacations.map{ |v| v.account_name }.inspect

# merge vacation requests from the two above sources
vacations.add email_analyser.vacations

verboser "\n***** STEP 2: manage the Sieve scripts for *****\n"
verboser "Number of requests to process: #{vacations.length}"

# Now that we have a complete set of vacation requests, we want to
# to install/remove sieve scripts.
vacations.each do |vac|
  #puts vac.to_s

  if vac.deactivated_at.in_the_past?
    verboser "Deactivating autoresponder for #{vac.account_name}"

    uninstall_sieve_script vac
    vac.cancel

    if vac.activated?
      Mailer.notify_vacation_autoresponder_deactivated vac
    else
      Mailer.notify_vacation_autoresponder_not_found vac
    end

  elsif !vac.activated? && vac.activated_at.in_the_past?
    verboser "Activating autoresponder for #{vac.account_name}"

    install_sieve_script vac
    vac.activate

    Mailer.notify_vacation_autoresponder_activated vac

#  elsif vac.activated_at.in_the_future?
#    verboser "Skipping #{vac.account_name}. Activation is still in the future"

  end
end

# write updated vacations.yaml
vacations.save

# EOF ################################################################
