#!/usr/bin/env ruby

# # #
# gems used:
#  https://github.com/ktheory/maildir
#  https://github.com/mikel/mail
#
# NOTE: ideally, this script should run as the user under which
# Dovecot runs, for example, vmail
#
# Architecture
# 1. a script that extracts instructions from user emails
#    and writes this data into another file (vacations.yaml)
#    TODO: add 'activate: now' to allowed syntax
#          this should also be default for cancel operation
# 2. TODO: a script that installs and removes Sieve scripts
#    according to vacation.yaml.
#    Notification should be sent to the user both when
#    the script is installed or removed
#    Ensure that (de)activation succeeds even if the datetime
#    is in the past.
# 
# 1. avoid processing autoreplies :)
#    an autoresponder is installed
#    the user sends another msg (for canceling)
#    autoresponder replies
#    this script should not send a HOWTO to this reply
#
# TODO: wrap into VacationAutoresponder class?
#
# Examples to try:
# manage_vacation --show-sieve-script --from=talpus@gmail.com,tux@linguistics.rub.de

require 'maildir'
require 'mail'
require 'yaml'
require 'time'
require 'optparse'

######################################################################
# extensions to core classes (just for fun)

class Hash
  def symbolize_keys
    each_with_object({}) do |(k,v), hash|
      hash[k.to_sym] = v
    end
  end
end

class Fixnum

  # expressed in seconds
  def hours
    self * 60 * 60
  end
  alias hour hours

  # expressed in minutes
  def minutes
    self * 60
  end
  alias minute minutes

  # expressed in seconds
  def days
    self * 24.hours
  end
  alias day days
end

class Time
  def in_the_past?
    self < Time.now
  end
end

######################################################################
# TODO: store it in a YAML file?

class Conf
  class << self
    def mailboxes_dir
      "/home/mkrot/projects/my-linux-tools/tmp/"
    end

    def smtp_conf_file
      File.join mailboxes_dir, "smtp.conf"
    end

    # TODO: here vacation/ directory is actually mail account name
    # of vacation autoresponder service.
    def vacations_conf_file
      File.join mailboxes_dir, "vacation", "vacations.yml"
    end

    def dovecot_users_file
      #"/etc/dovecot/users" or "/etc/dovecot/linguistics.rub.de/users"
      "/home/mkrot/projects/my-linux-tools/tmp/users"
    end

    def mail_home account
      File.join mailboxes_dir, account
    end

    def mail_dir account
      File.join mail_home(account), "Maildir"
    end

    def sieve_dir account
      File.join mail_home(account), "sieve"
    end

    def sieve_vacation_file account
      File.join sieve_dir(account), "vacation.sieve"
    end

    def sieve_main_file account
      File.join sieve_dir(account), "main.sieve"
    end

    # As defined in /etc/dovecot/conf.d/90-sieve.conf
    # this should be the *link* to a script in sieve/
    # the link is normally managed by ManageSieve
    def sieve_active_file account
      File.join mail_home(account), ".dovecot.sieve"
    end
  end
end

#puts Conf.mailboxes_dir
#puts Conf.smtp_conf_file
#puts Conf.vacations_conf_file
#puts Conf.dovecot_users_file

######################################################################
# Mailer configuration

smtp_config = YAML.load_file(Conf.smtp_conf_file).symbolize_keys

Mail.defaults do
  delivery_method :smtp, smtp_config
end

######################################################################

class SieveScript
  class << self

    def main
      lines = []
      lines << 'require ["include"];'
      lines << 'include :personal "vacation";'
      lines.join("\n")
    end

    # checks that main.sieve contains necessary lines
    # see #main for details
    def insert_vacation! lines

      changed = false
      has_require_include = false
      has_include_vacation = false

      lines.map! do |line|
        line.chomp!

        # Ensure that 'include' library is imported
        if line =~ /^require/ && !has_require_include
          if line !~ /['"]include['"]/
            line.sub!(/\]/, ", \"include\"]")
            changed = true
          end
          has_require_include = true
        end

        # check that vacation is included
        if line =~ /include\s+:personal\s+['"]vacation['"]/
          has_include_vacation = true
        end

        line
      end

      unless has_require_include
        lines.unshift "require [\"include\"];"
        changed = true
      end

      unless has_include_vacation
        lines.push 'include :personal "vacation";'
        changed = true
      end

      changed
    end

    def activate_vacation! lines
      changed = false

      lines.map! do |line|
        line.chomp!
        if line =~ /include\s+:personal\s+['"]vacation['"]/ && line =~ /^#/
          line.sub! /^#.*include/, "include"
          changed = true
        end
        line
      end

      changed
    end

    def vacation args=nil

      lines = []
      lines << "# This file is generated by the script #{$0}"
      lines << "# DO NOT EDIT. Chances are your changes will be overriden."
      lines << ""
      lines << 'require ["variables", "vacation"];'
      lines << ""
      
      # set variable <originalSubject>
      lines << 'if header :matches "Subject" "*" { set "originalSubject" ": ${1}"; }'
      lines << ""

      indent = ""
      if args.key? :from
        from = [ args[:from] ].flatten(1).map do |addr|
          "header :contains \"from\" \"#{addr}\""
        end.join(", ")
        lines << "if anyof (#{from}) {"
        indent = "    "
      end

      subject = '[Autoreply] Out of office\${originalSubject}'

      lines << indent + "vacation"
      lines << indent + "  :days 1"
      lines << indent + "  :subject \"#{subject}\""
      lines << indent + "  :text\n#{args[:text]}\n;"

      if args.key? :from
        lines << "}"
      end

      lines.join("\n")
    end
  end
end

######################################################################
# class for managing vacations.yaml
#
# read the file
# get a single entry as Vacation object

class VacationsFile
  attr_reader :data

  def self.example
    Vacation.sample_entry_for_config.to_yaml
  end

  def initialize filename
    @filepath = filename

    if File.exists? @filepath
      @data = YAML.load_file @filepath
    else
      @data = YAML.load example.to_yaml
    end
  end

  def method_missing meth, *args
    @data.send meth, *args
  end

  # TODO: do not save vacations that are canceled
  # Hopefully, corresponding Sieve script has been uninstalled
  def save
    File.open(@filepath, "w+") do |file|
      YAML.dump @data, file
    end
  end
  alias close save

  def example
    Vacation.sample_entry_for_config
  end

  # TODO: needs refactoring
  def add vac
    if vac.is_a? Array
      vac.each{ |v| add v }
    else
      # add single Vacation
      if vac.respond_to? :for_config
        vac = vac.for_config #=> Hash
      end
      # add Hash
      vac.keys.each do |key|
        if @data.key? key
          @data.delete key
        end
        @data[key] = vac[key]
      end
    end
  end

  # convert items in 
  # TODO: ugly. this is temporary
  def convert_to_vacation!
    @data.each do |key, hash|
      unless hash.is_a? Vacation
        vac = Vacation.new
        vac.account_name   = key
        vac.account_email  = hash["email"]
        vac.activated_at   = hash["activation_time"]
        vac.deactivated_at = hash["deactivation_time"]
        vac.message        = hash["message"]
        @data[key] = vac
      end
    end
  end

  def each
    @data.each do |account, vacation|
      yield vacation
    end
  end
end

######################################################################

class Vacation
  attr_reader   :starts_at, :ends_at
  attr_reader   :activated_at, :deactivated_at
  attr_accessor :requested_at
  attr_accessor :account_name, :account_email
  attr_accessor :email_file
  attr_reader   :errors

  attr_accessor :closed

  def self.howto
    outs = []
    outs << "1) How to activate autoresponder. when becomes effective."
    outs << "2) How to cancel autoresponder. when becomes effective"
    outs << "3) when syntax is incorrect, this message is sent."
    outs.join("\n")
  end

  def self.sample_entry_for_config
    obj = self.new

    obj.account_name  = "johnsmith"
    obj.account_email = "john.smith@example.com"
    obj.starts_at = "13.1.2016"
    obj.ends_at = "29.1.2016"
    obj.message = "Example: I am on vacation from #{obj.starts_at} till #{obj.ends_at}."

    obj.for_config
  end

  def initialize text=nil
    @closed = false
    @parsing_message = false
    @errors = []
    @deleted = false

    parse text  if text
  end

  # TODO: test if works with html
  # TODO: add 'activate: now'
  def parse text

    puts "=== parsing text to find Vacation ==="
    puts text

    text.split(/\n/).each do |line|
      line.chomp!
      if line =~ /^=vacation/
        reset_parsed
      elsif line =~ /=end/
        @closed = true
        break
      elsif line =~ /^cancel/
        cancel
      elsif line =~ /^activate:\t*(now|jetzt)/
        raise "ERROR: not supported:\n#{line}"
      elsif line =~ /^first (?:day|date):(.+)/
        self.starts_at = $1
      elsif line =~ /^last (?:day|date):(.+)/
        self.ends_at = $1
      elsif line =~ /^message:(.*)/
        @message = $1.strip
        @parsing_message = true
      elsif parsing_message?
        @message << "\n" << line
      end
    end

    validate
  end

  def reset_parsed
    @starts_at = @ends_at = nil
    @message = nil
    @parsing_message = false
  end

  def starts_at= val
    @parsing_message = false
    @starts_at = val.is_a?(Date) ? val : Date.parse(val)

    # Set Autoresponder activation time at 18:00 of the day
    # before user vacation starts.
    # If it happens to be on weekend, move it further to Friday
    @activated_at = @starts_at.to_time - 6.hours
    if @activated_at.sunday?
      @activated_at -= 2.days
    elsif @activated_at.saturday?
      @activated_at -= 1.day
    end

    @starts_at
  end

  def ends_at= val
    @parsing_message = false
    @ends_at = val.is_a?(Date) ? val : Date.parse(val)

    # set Autoresponder deactivation time at 18:00 of the last
    # day of the user's vacation
    @deactivated_at = @ends_at.to_time + 18.hours

    @ends_at
  end

  def activated_at= val
    @activated_at = to_time val
  end

  def deactivated_at= val
    @deactivated_at = to_time val
  end

  def message?
    !@message.to_s.empty?
  end

  def message= str
    @message = str.dup
  end

  def message
    @message || message_default
  end

  def message_default
    "I am on vacation from #{starts_at || 'NoDate'} through #{ends_at || 'NoDate'}."
  end

  def parsing_message?
    @parsing_message
  end

  def cancel
    @canceled = true
    @deactivated_at = Time.now - 1
  end

  def canceled?
    @canceled
  end

  def valid_request?
    @errors.empty?
  end

  def to_s
    out = []
    out << "account: #{account_name}"
    out << "email: #{account_email}"
    if canceled?
      out << "vacation: canceled"
      out << "deactivated_at: #{deactivated_at}"
    else
      out << "from: #{starts_at}"
      out << "till: #{ends_at}"
      out << "message:\n#{message}\nend_of_message"
      out << "*requested at: #{requested_at}"
      out << "*activated_at: #{activated_at}"
      out << "*deactivated_at: #{deactivated_at}"
      out << "*email path: #{email_file.path}"
    end
    out.join("\n")
  end

  # TODO: ugly. maybe move converter to VacationFile?
  def for_config
    #.iso8601               #=> 2015-11-13T18:00:00+01:00
    fmt = "%F %T %z"        #=> 2015-11-25 18:00:00 +0100
    #fmt = "%d.%m.%Y %T %z" #=> 13.11.2015 18:00:00 +0100
    #puts deactivated_at.strftime(fmt)

    {
      account_name => {
        "email"             => account_email,
        "activation_time"   => activated_at   ? 
                                 activated_at.strftime(fmt)   : nil,
        "deactivation_time" => deactivated_at ? 
                                 deactivated_at.strftime(fmt) : nil,
        "message"           => message? ? message : nil
      }
    }
  end

  private

  def closed= v
    @closed = v
    @parsing_message = false  if @closed
  end

  def validate
    if canceled?
      # nothing to check

    else
      # check dates specified by the user
      if self.starts_at && self.ends_at

        if self.ends_at < self.starts_at
          @errors << "Vacation last day can not be before the first day"
        elsif self.ends_at < Date.today
          @error << "Vacation last day can not be in the past"
        end

      else
        unless self.starts_at
          @errors << "must contain the first date of vacation"
        end
        unless self.ends_at
          @errors << "must contain the last date of vacation"
        end
      end
    end
  end

  def to_time val
    val.is_a?(Time) ? val : Time.parse(val)
  end
end

######################################################################

class EmailAnalyser
  attr_accessor :account_name
  attr_accessor :debug

  def initialize
    @maildir_path = nil
    @maildir = nil
    @mydomains = []
    @vacations = []

    @debug = false
  end

  def maildir_path= path
    if File.directory? path
      @maildir_path = path
    else
      $stderr.puts "ERROR: Maildir not found: #{path}"
      exit 1
    end
  end

  def my_domains= domains
    @my_domains = domains.dup
  end

  def maildir
    @maildir ||= Maildir.new @maildir_path, false
  end

  def vacations
    @vacations.dup
  end

  def process_emails
    parse_emails
    analyse_vacations
    @vacations
  end

  private

  def parse_emails
    @vacations_from_emails = Hash.new{ |h,k| h[k] = [] }

    [:cur, :new].each do |loc|
      maildir.list(loc).each do |mailfile|

        if @debug
          puts "\n\n=== Processing Email ==="
          puts mailfile.path
        end

        msg = Mail.read mailfile.path

        unless mail_to_me? msg
          puts "Not a mail to me"
          next
        end

        senders = senders_in_my_domain(msg)

        if senders.empty?
          puts "Sender not in our domain: #{msg.from}"
          next
        end

        if msg.multipart?
          msg_body = msg.text_part || msg.html_part
        else
          msg_body = msg.body
        end

        vac = Vacation.new msg_body.decoded

        # TODO: in theory, there can be several addresses in the From
        # field and consequently in the senders array. But we ignore
        # this situation for the moment.
        
        # Keep the original sender address to be able to send a notice
        # back to the user.
        vac.account_email = senders.first

        # Store account name that will be used for:
        # - computing the path to the mailbox
        # - identifying vacation emails belonging to the same user
        vac.account_name = get_account_name(vac.account_email)

        # Set date on which request date was received.
        # Necessary for finding out the vacation request that is most
        # up-to-date and needs to be reacted.
        vac.requested_at = msg.date

        # Attach original email file, we may want to manipulate it
        vac.email_file = mailfile
        
        if @debug
          puts "=== Vacation object ==="
          #puts vac.inspect
          puts vac.to_s
        end
        
        @vacations_from_emails [vac.account_name] << vac
      end
    end
  end

  def analyse_vacations
    @vacations = []

    @vacations_from_emails.each do |account, vacs|
      puts "\n### #{vacs.length} vacation request(s) from account: #{account}"

      # sort messages from a single account in descending order
      # so that the most recent message comes first
      vacs.sort_by!{ |vac| vac.requested_at }.reverse!
  
      howto_message_sent = false
      ignore_remaining_requests = false

      vacs.each do |vac|
        puts "== Vacation request user #{account}"
        puts vac.to_s
        puts "= yaml ="
        puts vac.for_config.to_yaml
        puts "\n"
        
        if ignore_remaining_requests
          # skip

        elsif vac.valid_request?
          
          @vacations << vac
          ignore_remaining_requests = true
          
          if vac.canceled?
            notify_vacation_autoresponder_canceled vac
          else
            notify_vacation_autoresponder_accepted vac
          end
          
        elsif ! howto_message_sent
          # send HOWTO message if the user sent us an incorrect request,
          # but do it only once
          send_howto_message vac
          howto_message_sent = true
          
        end

        # delete this message
        # we dont want to process it next time the script is run
        #vac.email_file.add_flag("T") # does not delete but merely marks as Trashed
        #vac.email_file.destroy # TODO: yes, uncomment
      end
    end
  end

  def my_email_addresses
    @my_email_addresses ||= @my_domains.map do |domain| 
      "#{@account_name}@#{domain}"
    end
  end

  def senders_in_my_domain msg
    # as per RFC, the From field can contain several addresses
    senders = msg.from.select do |addr|
      username, domain, other = addr.split '@'
      @my_domains.include?(domain.downcase)
    end
    senders
  end

  def mail_to_me? msg
    rcpt_addresses = [:to, :cc].map do |meth|
      msg.send(meth)
    end.flatten.compact.map(&:downcase)
    !(my_email_addresses - rcpt_addresses).empty?
  end

  def dovecot_accounts
    unless @dovecot_accounts
      @dovecot_accounts = {}
      load_dovecot_users
    end
    @dovecot_accounts
  end

  def load_dovecot_users
    return unless Conf.dovecot_users_file
    
    if File.exists? Conf.dovecot_users_file
      File.readlines(Conf.dovecot_users_file).each do |line|
        line = line.chomp.sub(/\s#.*/, "")
        if line =~ /^([^\s#:]+):.+user=([^\s@]+)@/
          login_name, new_name = $1.downcase, $2.downcase
          if @dovecot_accounts.key? login_name
            $stderr.puts "WARNING: Duplicate login names in #{Conf.dovecot_users_file}: #{login_name}"
          end
          if login_name != new_name
            @dovecot_accounts[login_name] = new_name
          end
        end
      end
    else
      $stderr.puts "ERROR: Dovecot users file not found: #{Conf.dovecot_users_file}"
      exit 2
    end
  end

  # resolve to the same account synonyms
  def get_account_name email_addr
    account, other = email_addr.split '@'
    account.downcase! # Dovecot also does the same
    if dovecot_accounts.key? account
      account = dovecot_accounts[account]
    end
    account
  end

  def create_mail_to addr
    Mail.new to: addr, from: my_email_addresses.first
  end

  def send_howto_message vac

    msg = "Your message does not contain valid activation or cancelation"
    msg << " instructions. The following errors were encountered:"
    vac.errors.each_with_index do |err, i|
      msg << "\n #{i+1}) #{err}"
    end
    msg << "\n\nTherefore this very HOWTO is sent to you.\n\n" 
    msg << Vacation.howto
    
    mail = create_mail_to vac.account_email
    mail.subject = 'Vacation Autoresponder HOWTO'
    mail.body    = msg
    
    #mail.deliver! #TODO, good, uncomment
  end
  
  def notify_vacation_autoresponder_accepted vac
    
    msg = "Vacation request accepted for the user"
    msg << " #{vac.account_name}\n"
    msg << "autoresponder will be activated on: #{vac.activated_at}"
    msg << " and deactivated on: #{vac.deactivated_at}"
    
    mail = create_mail_to vac.account_email
    
    mail.subject = 'Vacation request accepted'
    mail.body    = msg

    #mail.deliver! # TODO, good, uncomment
  end

  def notify_vacation_autoresponder_canceled vac
    msg = "Vacation Autoresponder will be deactivated for the user"
    msg << " #{vac.account_name} shortly."
    
    mail = create_mail_to vac.account_email
    
    mail.subject = 'Vacation Cancelation request accepted'
    mail.body    = msg
    
    #mail.deliver! #TODO, good, uncomment
  end
end

######################################################################
# other methods

def verboser msg
  if @options[:debug]
    puts msg
  end
end

def create_sieve_environment account
  verboser "Creating Sieve environment for #{account}"

  sieve_dir = Conf.sieve_dir account
  unless Dir.exists? sieve_dir
    Dir.mkdir sieve_dir
  end

  # write main.sieve file or make amendments to already existing file
  sieve_main_file = Conf.sieve_main_file account
  if File.exist? sieve_main_file
    verboser "ensuring that existing #{sieve_main_file} file contains relevant code"
    lines = IO.readlines sieve_main_file
    if SieveScript.insert_vacation! lines
      File.open sieve_main_file, "w+" do |file|
        file.puts lines.join("\n")
      end
    end

  else
    verboser "writing new #{sieve_main_file} file"
    File.open sieve_main_file, "w+" do |file|
      file.puts SieveScript.main
    end
  end

  # Link active sieve script to sieve/main.sieve
  sieve_active_file = Conf.sieve_active_file(account)
  verboser "Symlinking #{sieve_active_file} to #{sieve_main_file}"
  if File.exists? sieve_active_file
    File.delete sieve_active_file
  end
  File.symlink sieve_main_file, sieve_active_file
end

def install_sieve_script vac
  create_sieve_environment vac.account_name

  # write vacation.sieve file
  sieve_vacation_file = Conf.sieve_vacation_file vac.account_name
  verboser "Writing #{sieve_vacation_file} file"
  File.open sieve_vacation_file, "w+" do |file|
    # TODO: add from: @options[:from_senders] ?
    file.puts SieveScript.vacation text: vac.message
  end

  # amend main.sieve file
  sieve_main_file = Conf.sieve_main_file vac.account_name
  verboser "Activating vacation entry in #{sieve_main_file}"
  lines = IO.readlines sieve_main_file
  if SieveScript.activate_vacation! lines
    File.open sieve_main_file, "w+" do |file|
      file.puts lines.join("\n")
    end
  end

  # send notification to the user
  msg = "Dear user,"
  msg << "\nVacation autoresponder has just been activated for you."
  msg << "The following message will be sent:\n#{vac.message}"
  msg << "\nIt will be deactivated on #{vac.deactivation_time}"

  mail = create_mail_to vac.account_email
  mail.subject = 'Vacation Autoresponder activated'
  mail.body    = msg

  #mail.deliver! # TODO, good, uncomment
end

# TODO
def uninstall_sieve_script vac
  # vac.account_name
  maildir = Conf.mail_dir vac.account_name
  # TODO: send notification to the user
  # vac.account_email
end

######################################################################
# process options

@options = {}

OptionParser.new do |opts|
  opts.banner = "
  Do Cool Stuff
In the current implementation all configuration parameters are hardcoded.
The script works with Maildir format only.
USAGE: #{File.basename($0)} [OPTIONS]
"
  opts.on('-h', '--help', 'display this message and exit') do
    puts opts
    exit 0
  end

  opts.on('--show-config-example', 'show example of vacations.yaml') do
    puts Vacation.sample_entry_for_config.to_yaml
    exit 0
  end

  @options[:show_sieve_script] = false
  opts.on('--show-sieve-script',
          'show the content of vacation.sieve script that will be installed',
          'In addition, try it with --from option.') do
    @options[:show_sieve_script] = true
  end

  @options[:from_senders] = nil
  opts.on('--from=email1,email2',
          'make sieve script active with specified sender addresses only.',
          'Especially useful for testing purposes.') do |addresses|
    @options[:from_senders] = addresses.split(",")
  end

  @options[:debug] = false
  opts.on('--debug', 'self explanatory') do
    @options[:debug] = true
  end

  opts.separator " "
end.parse!

if @options[:show_sieve_script]
  params = { text: 'I am on vacation' }
  if @options[:from_senders]
    params[:from] = @options[:from_senders]
  end
  puts SieveScript.vacation params
  exit 0
end

######################################################################
# MAIN

# load vacation requests from vacations.yaml
vacations = VacationsFile.new Conf.vacations_conf_file

# find new vacation autoresponder requests in the mailbox
resp = EmailAnalyser.new
resp.account_name = "vacation"
resp.maildir_path = Conf.mail_dir resp.account_name
resp.my_domains = ["linguistics.rub.de", "linguistics.ruhr-uni-bochum.de"]
#resp.debug = @options[:debug]

resp.process_emails
vacations.add resp.vacations

verboser "\n***** STEP 2: manage the Sieve scripts for *****\n"
verboser "Number of requests to process: #{vacations.length}"

# TODO: ugly!! get rid of it, refactor VacationsFile
vacations.convert_to_vacation!

# Now that we have a complete set of vacation requests, we want to
# to install/remove sieve scripts.
vacations.each do |vac|
  puts vac.inspect

  if vac.deactivated_at.in_the_past?
    verboser "Deactivating autoresponder for #{vac.account_name}"
    uninstall_sieve_script vac
    vac.cancel  # delete this entry from vacations.yaml

  elsif vac.activated_at.in_the_past?
    verboser "Activating autoresponder for #{vac.account_name}"
    install_sieve_script vac

  end
end

# write updated vacations.yaml
#vacations.save

