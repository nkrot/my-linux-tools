#!/usr/bin/env ruby

# # #
# gems used:
#  https://github.com/ktheory/maildir
#  https://github.com/mikel/mail
#
# Architecture
# 1. a script that extracts instructions from user emails
#    and writes this data into another file (vacations.yaml)
#    TODO: add 'activate: now' to allowed syntax
#          this should also be default for cancel operation
# 2. TODO: a script that installs and removes Sieve scripts
#    according to vacation.yaml.
#    Notification should be sent to the user both when
#    the script is installed or removed
#    Ensure that (de)activation succeeds even if the datetime
#    is in the past.
# 
# Include in the help message:
#  - works with Maildir format only
#
# 1. avoid processing autoreplies :)
#    an autoresponder is installed
#    the user sends another msg (for canceling)
#    autoresponder replies
#    this script should not send a HOWTO to this reply
#
# TODO: wrap into VacationAutoresponder class?

require 'maildir'
require 'mail'
require 'yaml'
require 'time'

@mailboxes_dir = "/home/mkrot/projects/my-linux-tools/tmp/"
@dovecot_users_file = "/home/mkrot/projects/my-linux-tools/tmp/users"
@debug = false

@smtp_config_file = @mailboxes_dir + "/smtp.conf"
@vacations_file = @mailboxes_dir + "/vacation/vacations.yml"

######################################################################
# extensions to core classes (just for fun)

class Hash
  def symbolize_keys
    each_with_object({}) do |(k,v), hash|
      hash[k.to_sym] = v
    end
  end
end

class Fixnum

  # expressed in seconds
  def hours
    self * 60 * 60
  end
  alias hour hours

  # expressed in minutes
  def minutes
    self * 60
  end
  alias minute minutes

  # expressed in seconds
  def days
    self * 24.hours
  end
  alias day days
end

######################################################################
# Mailer configuration

smtp_config = YAML.load_file(@smtp_config_file).symbolize_keys

Mail.defaults do
  delivery_method :smtp, smtp_config
end

######################################################################
# class for managing vacations.yaml
#
# read the file
# get a single entry as Vacation object

class VacationsFile
  attr_reader :data

  def initialize filename
    @filepath = filename

    if File.exists? @filepath
      @data = YAML.load_file @filepath
    else
      @data = YAML.load example.to_yaml
    end
  end

  def method_missing meth, *args
    @data.send meth, *args
  end

  def save
    File.open(@filepath, "w+") do |file|
      YAML.dump @data, file
    end
  end
  alias close save

  def example
    Vacation.sample_entry_for_config
  end

  def add vac
    if vac.respond_to? :for_config
      vac = vac.for_config
    end
    vac.keys.each do |key|
      if @data.key? key
        @data.delete key
      end
      @data[key] = vac[key]
    end
  end
end

def vacations_config
  @vacations_config ||= VacationsFile.new(@vacations_file)
end

######################################################################

class Vacation
  attr_reader   :starts_at, :ends_at
  attr_reader   :activated_at, :deactivated_at
  attr_accessor :requested_at
  attr_accessor :account_name, :account_email
  attr_accessor :email_file
  attr_reader   :errors

  attr_accessor :closed

  def self.howto
    outs = []
    outs << "1) How to activate autoresponder. when becomes effective."
    outs << "2) How to cancel autoresponder. when becomes effective"
    outs << "3) when syntax is incorrect, this message is sent."
    outs.join("\n")
  end

  def self.sample_entry_for_config
    obj = self.new

    obj.account_name  = "accountName"
    obj.account_email = "accountName@example.com"
    obj.starts_at = "1.1.2016"
    obj.ends_at = "10.1.2016"
    obj.message = obj.message_default

    obj.for_config
  end

  def initialize text=nil
    @closed = false
    @parsing_message = false
    @errors = []

    parse text  if text
  end

  # TODO: test if works with html
  def parse text

    puts "=== parsing text to find Vacation ==="
    puts text

    text.split(/\n/).each do |line|
      line.chomp!
      if line =~ /^=vacation/
        reset_parsed
      elsif line =~ /=end/
        @closed = true
        break
      elsif line =~ /^cancel/
        cancel
      elsif line =~ /^first (?:day|date):(.+)/
        self.starts_at = $1
      elsif line =~ /^last (?:day|date):(.+)/
        self.ends_at = $1
      elsif line =~ /^message:(.*)/
        @message = $1.strip
        @parsing_message = true
      elsif parsing_message?
        @message << "\n" << line
      end
    end

    validate
  end

  def reset_parsed
    @starts_at = @ends_at = nil
    @message = nil
    @parsing_message = false
  end

  def starts_at= val
    @parsing_message = false
    @starts_at = val.is_a?(Date) ? val : Date.parse(val)

    # Set Autoresponder activation time at 18:00 of the day
    # before user vacation starts.
    # If it happens to be on weekend, move it further to Friday
    @activated_at = @starts_at.to_time - 6.hours
    if @activated_at.sunday?
      @activated_at -= 2.days
    elsif @activated_at.saturday?
      @activated_at -= 1.day
    end

    @starts_at
  end

  def ends_at= val
    @parsing_message = false
    @ends_at = val.is_a?(Date) ? val : Date.parse(val)

    # set Autoresponder deactivation time at 18:00 of the last
    # day of the user's vacation
    @deactivated_at = @ends_at.to_time + 18.hours

    @ends_at
  end

  def message?
    !@message.to_s.empty?
  end

  def message= str
    @message = str.dup
  end

  def message
    @message || message_default
  end

  def message_default
    "I am on vacation from #{starts_at || 'NoDate'} through #{ends_at || 'NoDate'}."
  end

  def parsing_message?
    @parsing_message
  end

  def cancel
    @canceled = true
    @deactivated_at = Time.now
  end

  def canceled?
    @canceled
  end

  def valid_request?
    @errors.empty?
  end

  def to_s
    out = []
    out << "account: #{account_name}"
    out << "email: #{account_email}"
    if canceled?
      out << "vacation: canceled"
      out << "deactivated_at: #{deactivated_at}"
    else
      out << "from: #{starts_at}"
      out << "till: #{ends_at}"
      out << "message:\n#{message}\nend_of_message"
      out << "*requested at: #{requested_at}"
      out << "*activated_at: #{activated_at}"
      out << "*deactivated_at: #{deactivated_at}"
      out << "*email path: #{email_file.path}"
    end
    out.join("\n")
  end

  def for_config
    #.iso8601               #=> 2015-11-13T18:00:00+01:00
    fmt = "%F %T %z"        #=> 2015-11-25 18:00:00 +0100
    #fmt = "%d.%m.%Y %T %z" #=> 13.11.2015 18:00:00 +0100
    #puts deactivated_at.strftime(fmt)

    {
      account_name => {
        "email"             => account_email,
        "activation_time"   => activated_at   ? 
                                 activated_at.strftime(fmt)   : nil,
        "deactivation_time" => deactivated_at ? 
                                 deactivated_at.strftime(fmt) : nil,
        "message"           => message? ? message : nil
      }
    }
  end

  private

  def closed= v
    @closed = v
    @parsing_message = false  if @closed
  end

  def validate
    if canceled?
      # nothing to check

    else
      # check dates specified by the user
      if self.starts_at && self.ends_at

        if self.ends_at < self.starts_at
          @errors << "Vacation last day can not be before the first day"
        elsif self.ends_at < Date.today
          @error << "Vacation last day can not be in the past"
        end

      else
        unless self.starts_at
          @errors << "must contain the first date of vacation"
        end
        unless self.ends_at
          @errors << "must contain the last date of vacation"
        end
      end
    end
  end

end

######################################################################

def senders_in_our_domain msg
  # as per RFC, the From field can contain several addresses
  senders = msg.from.select do |addr|
    username, domain, other = addr.split '@'
    @our_domains.include?(domain.downcase)
  end
  senders
end

def mail_to_me? msg
  rcpt_addresses = [:to, :cc].map do |meth|
    msg.send(meth)
  end.flatten.compact.map(&:downcase)
  !(@my_email_addresses - rcpt_addresses).empty?
end

def path_to_maildir account
  File.join @mailboxes_dir, account, "Maildir"
end

def dovecot_accounts
  unless @dovecot_accounts
    @dovecot_accounts = {}
    load_dovecot_users
  end
  @dovecot_accounts
end

def load_dovecot_users
  return unless @dovecot_users_file

  if File.exists? @dovecot_users_file
    File.readlines(@dovecot_users_file).each do |line|
      line = line.chomp.sub(/\s#.*/, "")
      if line =~ /^([^\s#:]+):.+user=([^\s@]+)@/
        login_name, new_name = $1.downcase, $2.downcase
        if @dovecot_accounts.key? login_name
          $stderr.puts "WARNING: Duplicate login names in #{@dovecot_users_file}: #{login_name}"
        end
        if login_name != new_name
          @dovecot_accounts[login_name] = new_name
        end
      end
    end
  else
    $stderr.puts "ERROR: Dovecot users file not found: #{@dovecot_users_file}"
    exit 2
  end
end

# resolve to the same account synonyms
def get_account_name email_addr
  account, other = email_addr.split '@'
  account.downcase! # Dovecot also does the same
  if dovecot_accounts.key? account
    account = dovecot_accounts[account]
  end
  account
end

def create_mail_to addr
  Mail.new to: addr, from: @my_email_addresses.first
end

def send_howto_message vac

  msg = "Your message does not contain valid activation or cancelation"
  msg << " instructions. The following errors were encountered:"
  vac.errors.each_with_index do |err, i|
    msg << "\n #{i+1}) #{err}"
  end
  msg << "\n\nTherefore this very HOWTO is sent to you.\n\n" 
  msg << Vacation.howto

  mail = create_mail_to vac.account_email
  mail.subject = 'Vacation Autoresponder HOWTO'
  mail.body    = msg

  #mail.deliver! #TODO
end

def notify_vacation_autoresponder_activated vac

  msg = "Vacation Autoresponder request accepted for the user"
  msg << " #{vac.account_name}\n"
  msg << "autoresponder will be activated on: #{vac.activated_at}"
  msg << " and deactivated on: #{vac.deactivated_at}"

  mail = create_mail_to vac.account_email

  mail.subject = 'Vacation Autoresponder activated'
  mail.body    = msg

  #mail.deliver! # TODO
end

def notify_vacation_autoresponder_canceled vac
  msg = "Vacation Autoresponder will be deactivated for the user"
  msg << " #{vac.account_name} shortly."

  mail = create_mail_to vac.account_email

  mail.subject = 'Vacation Autoresponder canceled'
  mail.body    = msg

  #mail.deliver! #TODO
end

######################################################################

service = "vacation"
service_maildir_path = path_to_maildir service

@our_domains = ["linguistics.rub.de", "linguistics.ruhr-uni-bochum.de"]
@my_email_addresses = @our_domains.map { |dmn| "#{service}@#{dmn}" }

unless File.directory? service_maildir_path
  $stderr.puts "ERROR: Maildir not found: #{service_maildir_path}"
  exit 1
end

vacations = Hash.new{ |h,k| h[k] = [] }

service_maildir = Maildir.new service_maildir_path, false

[:cur, :new].each do |loc|
  service_maildir.list(loc).each do |mailfile|

    if @debug
      puts "\n\n=== Processing Email ==="
      puts mailfile.path
    end

    msg = Mail.read(mailfile.path)

    unless mail_to_me? msg
      puts "Not a mail to me"
      next
    end

    senders = senders_in_our_domain(msg)

    if senders.empty?
      puts "Sender not in our domain: #{msg.from}"
      next
    end

    if msg.multipart?
      msg_body = msg.text_part || msg.html_part
    else
      msg_body = msg.body
    end

    vac = Vacation.new msg_body.decoded

    # TODO: in theory, there can be several addresses in the From
    # field and consequently in the senders array. But we ignore
    # this situation for the moment.

    # Keep the original sender address to be able to send a notice
    # back to the user.
    vac.account_email = senders.first

    # Store account name that will be used for:
    # - computing the path to the mailbox
    # - identifying vacation emails belonging to the same user
    vac.account_name = get_account_name(vac.account_email)

    # Set date on which request date was received.
    # Necessary for finding out the vacation request that is most
    # up-to-date and needs to be reacted.
    vac.requested_at = msg.date

    # Attach original email file, we may want to manipulate it
    vac.email_file = mailfile

    if @debug
      puts "=== Vacation object ==="
      #puts vac.inspect
      puts vac.to_s
    end

    vacations [vac.account_name] << vac
  end
end

vacations.each do |account, vacs|
  puts "\n### #{vacs.length} vacation request(s) from account: #{account}"

  # sort messages from a single account in descending order
  # so that the most recent message comes first
  vacs.sort_by!{ |vac| vac.requested_at }.reverse!
  
  howto_message_sent = false
  ignore_remaining_requests = false

  vacs.each do |vac|
    puts "== Vacation request user #{account}"
    puts vac.to_s
    puts "= yaml ="
    puts vac.for_config.to_yaml
    puts "\n"

    if ignore_remaining_requests
      # skip

    elsif vac.valid_request?

      vacations_config.add vac
      ignore_remaining_requests = true

      if vac.canceled?
        notify_vacation_autoresponder_canceled vac
      else
        notify_vacation_autoresponder_activated vac
      end

    elsif ! howto_message_sent
      # send HOWTO message if the user sent us an incorrect request,
      # but do it only once
      send_howto_message vac
      howto_message_sent = true

    end

    # delete this message
    # we dont want to process it next time the script is run
    #vac.email_file.add_flag("T") # does not delete but merely marks as Trashed
    #vac.email_file.destroy # TODO: yes, uncomment
  end
end

vacations_config.close

