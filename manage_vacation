#!/usr/bin/env ruby

# # #
# gems used:
#  https://github.com/ktheory/maildir
#  https://github.com/mikel/mail
#
# NOTE: ideally, this script should run as the user under which
# Dovecot runs, for example, vmail
#
# 1. avoid processing autoreplies :)
#    autoresponder is installed
#    the user sends another msg (for canceling)
#    autoresponder replies
#    this script should not send a HOWTO to this reply
#
# TODO: wrap into VacationAutoresponder class?
# TODO: add 'activate: now' to allowed syntax
#       this should also be default for cancel operation
# TODO: add logging mechanism
# TODO: how to treat mail coming from illegal users
#       (users from different domains)? Delete?
# TODO: add --test mode that installs autoresponder
#       only for specific users and only with specific sender addresses
#       that can be defined in vacation_autoresponder.conf
#       and also via the command line
# TODO: write Vacation.howto
#
# Examples to try:
# manage_vacation --show-sieve-script --from=talpus@gmail.com,tux@linguistics.rub.de

require 'maildir'
require 'mail'
require 'yaml'
require 'time'
require 'optparse'

######################################################################
# extensions to core classes (just for fun)

class Hash
  def symbolize_keys
    each_with_object({}) do |(k,v), hash|
      if v.is_a? Hash
        v = v.symbolize_keys
      end
      hash[k.to_sym] = v
    end
  end
end

class Fixnum

  # expressed in seconds
  def hours
    self * 60 * 60
  end
  alias hour hours

  # expressed in minutes
  def minutes
    self * 60
  end
  alias minute minutes

  # expressed in seconds
  def days
    self * 24.hours
  end
  alias day days
end

class Time
  def in_the_past?
    self < Time.now
  end

  def in_the_future?
    self > Time.now
  end
end

######################################################################

class Conf

  class << self

    def file= path
      @@config = YAML.load_file(path).symbolize_keys
    end

    def from_service
      "#{@@config[:service_name]} <#{@@config[:service_email]}>"
    end

    def method_missing meth, *args
      @@config[meth.to_sym]
    end

    # TODO: maybe somewhere under /var/ ?
    def vacations_file
      File.join mailboxes_dir, 
                @@config[:service_account_name], # vacation
                @@config[:vacations_file]        # vacations.yml
    end

    def mail_home account
      File.join mailboxes_dir, account
    end

    def mail_dir account
      File.join mail_home(account), @@config[:mail_dir] # "Maildir"
    end

    def service_mail_dir
      mail_dir @@config[:service_account_name]
    end

    def sieve_dir account
      File.join mail_home(account), @@config[:sieve_dir] # "sieve"
    end

    def sieve_vacation_file account
      File.join sieve_dir(account), @@config[:sieve_vacation_file] #"vacation.sieve"
    end

    def sieve_main_file account
      File.join sieve_dir(account), @@config[:sieve_main_file] # "main.sieve"
    end

    def sieve_active_file account
      File.join mail_home(account), @@config[:sieve_active_file] # .dovecot.sieve
    end
  end
end

######################################################################

class Mailer
  class << self

    def send_mail other_params
      params = { from: Conf.from_service }.merge(other_params)
      mail = Mail.new params
      mail.deliver!
    end

    def send_howto_message vac
      msg = "Dear User,"
      msg << "\nYour message does not contain valid activation or cancelation"
      msg << " instructions. The following errors were encountered:"
      vac.errors.each_with_index do |err, i|
        msg << "\n #{i+1}) #{err}"
      end
      msg << "\n\nTherefore this very HOWTO is sent to you. Enjoy!\n\n" 
      msg << Vacation.howto

      params = {
        to:       vac.account_email,
        subject: 'Vacation Autoresponder HOWTO',
        body:     msg
      }

      send_mail params
    end

    def notify_vacation_autoresponder_accepted vac
    
      msg = "Vacation request accepted for the user"
      msg << " #{vac.account_name}\n"
      msg << "autoresponder will be activated on: #{vac.activated_at}"
      msg << " and deactivated on: #{vac.deactivated_at}"

      params = {
        to:       vac.account_email,
        subject: 'Vacation request accepted',
        body:     msg
      }

      send_mail params
    end

    def notify_vacation_autoresponder_canceled vac
      msg = "Dear User,"
      msg << "\nVacation Autoresponder will be deactivated for you shortly."

      params = {
        to:       vac.account_email,
        subject: 'Vacation Cancelation request accepted',
        body:     msg
      }

      send_mail params
    end

    def notify_vacation_autoresponder_activated vac

      msg = "Dear user,"
      msg << "\nVacation autoresponder has just been activated for you."
      msg << "The following message will be sent:\n#{vac.message}"
      msg << "\nIt will be deactivated on #{vac.deactivated_at}"

      params = {
        to:       vac.account_email,
        subject: 'Vacation Autoresponder activated',
        body:     msg
      }

      send_mail params
    end

    def notify_vacation_autoresponder_deactivated vac
      msg = "Dear user,"
      msg << "\nVacation autoresponder has just been deactivated."

      params = {
        to:       vac.account_email,
        subject: 'Vacation Autoresponder deactivated',
        body:     msg
      }

      send_mail params
    end
  end
end

######################################################################

class SieveScript
  class << self

    def main
      lines = []
      lines << 'require ["include"];'
      lines << 'include :personal "vacation";'
      lines.join("\n")
    end

    # checks that main.sieve contains necessary lines
    # see #main for details
    def insert_vacation! lines

      changed = false
      has_require_include = false
      has_include_vacation = false

      lines.map! do |line|
        line.chomp!

        # Ensure that 'include' library is imported
        if line =~ /^require/ && !has_require_include
          if line !~ /['"]include['"]/
            line.sub!(/\]/, ", \"include\"]")
            changed = true
          end
          has_require_include = true
        end

        # check that vacation is included
        if line =~ /include\s+:personal\s+['"]vacation['"]/
          has_include_vacation = true
        end

        line
      end

      unless has_require_include
        lines.unshift "require [\"include\"];"
        changed = true
      end

      unless has_include_vacation
        lines.push 'include :personal "vacation";'
        changed = true
      end

      changed
    end

    def activate_vacation! lines
      changed = false

      lines.map! do |line|
        line.chomp!
        if line =~ /include\s+:personal\s+['"]vacation['"]/ && line =~ /^#/
          line.sub! /^#.*include/, "include"  # uncomment the line
          changed = true
        end
        line
      end

      changed
    end

    def deactivate_vacation! lines
      changed = false

      lines.map! do |line|
        line.chomp!
        if line =~ /include\s+:personal\s+['"]vacation['"]/ && line !~ /^#/
          line = "#" + line  # comment the line
          changed = true
        end
        line
      end

      changed
    end

    def vacation args=nil

      lines = []
      lines << "# This file is generated by the script #{$0}"
      lines << "# DO NOT EDIT. Chances are your changes will be overriden."
      lines << ""
      lines << 'require ["variables", "vacation"];'
      lines << ""
      
      # set variable <originalSubject>
      lines << 'if header :matches "Subject" "*" { set "originalSubject" ": ${1}"; }'
      lines << ""

      indent = ""
      if args.key? :from
        from = [ args[:from] ].flatten(1).map do |addr|
          "header :contains \"from\" \"#{addr}\""
        end.join(", ")
        lines << "if anyof (#{from}) {"
        indent = "    "
      end

      subject = '[Autoreply] Out of office\${originalSubject}'

      lines << indent + "vacation"
      lines << indent + "  :days 1"
      lines << indent + "  :subject \"#{subject}\""
      lines << indent + "  :text\n#{args[:text]}\n;"

      if args.key? :from
        lines << "}"
      end

      lines.join("\n")
    end
  end
end

######################################################################
# class for managing vacations.yaml
#
# read the file
# get a single entry as Vacation object

class VacationsFile
  attr_reader :data

  def self.example
    Vacation.example_entry_for_config.to_yaml
  end

  def initialize filename
    @filepath = filename

    if File.exists? @filepath
      @data = YAML.load_file @filepath

      @data.each do |account_name, entry|
        vac = Vacation.new entry
        vac.account_name = account_name
        @data[account_name] = vac
      end

      # delete example entry
      @data.delete_if{ |k,v| v.example? }

    else
      @data = Hash.new
    end
  end

  def method_missing meth, *args
    @data.send meth, *args
  end

  def save
    data = {}

    # add the example entry, always at the beginning
    data.merge! Vacation.example_entry_for_config

    # add real entries, except those that have been canceled/deactivated
    @data.values.each do |vac|
      data.merge!(vac.for_config)  unless vac.canceled?
    end

    File.open(@filepath, "w+") do |file|
      YAML.dump data, file
    end
  end
  alias close save

  def add vac
    if vac.is_a? Array
      vac.each{ |v| add v }
    elsif vac.is_a? Vacation
      @data[vac.account_name] = vac
    end
  end

  def each
    @data.each do |account, vacation|
      yield vacation
    end
  end
end

######################################################################

class Vacation
  attr_reader   :starts_at, :ends_at
  attr_reader   :activated_at, :deactivated_at
  attr_accessor :requested_at
  attr_accessor :account_name, :account_email
  attr_accessor :email_file
  attr_reader   :errors

  attr_accessor :closed

  def self.howto
    outs = []
    outs << "1) How to activate autoresponder. when becomes effective."
    outs << "2) How to cancel autoresponder. when becomes effective"
    outs << "3) when syntax is incorrect, this message is sent."
    outs.join("\n")
  end

  def self.example_entry_for_config
    obj = self.new

    obj.account_name  = "johnsmith"
    obj.account_email = "john.smith@example.com"
    obj.starts_at = "13.1.2016"
    obj.ends_at = "29.1.2016"
    obj.message = "Example: I am on vacation from #{obj.starts_at} till #{obj.ends_at}."

    obj.for_config
  end

  def initialize obj=nil
    @closed = false
    @parsing_message = false
    @errors = []
    @deleted = false
    @fake = false
    @debug = false

    if !obj
      # skip
    elsif obj.is_a? String
      parse_text obj
    elsif obj.is_a? Hash
      parse_hash obj
    elsif obj.is_a? self.class
      # TODO: make a deep copy
    else
      raise "ERROR: Invalid data type #{obj.class} of:\n#{obj}"
    end

  end

  def parse_hash hash
    self.account_email  = hash["email"]
    self.activated_at   = hash["activation_time"]
    self.deactivated_at = hash["deactivation_time"]
    self.message        = hash["message"]

    @fake = self.account_email == "john.smith@example.com"
  end

  # TODO: test if works with html
  # TODO: add 'activate: now'
  def parse_text text

    if @debug
      puts "=== parsing text to find Vacation ==="
      puts text
    end

    text.split(/\n/).each do |line|
      line.chomp!
      if line =~ /^=vacation/
        reset_parsed
      elsif line =~ /=end/
        @closed = true
        break
      elsif line =~ /^cancel/
        cancel
      elsif line =~ /^activate:\t*(now|jetzt)/
        raise "ERROR: not supported:\n#{line}"
      elsif line =~ /^first (?:day|date):(.+)/
        self.starts_at = $1
      elsif line =~ /^last (?:day|date):(.+)/
        self.ends_at = $1
      elsif line =~ /^message:(.*)/
        @message = $1.strip
        @parsing_message = true
      elsif parsing_message?
        @message << "\n" << line
      end
    end

    validate
  end

  def reset_parsed
    @starts_at = @ends_at = nil
    @message = nil
    @parsing_message = false
  end

  def starts_at= val
    @parsing_message = false
    @starts_at = val.is_a?(Date) ? val : Date.parse(val)

    # Set Autoresponder activation time at 18:00 of the day
    # before user vacation starts.
    # If it happens to be on weekend, move it further to Friday
    @activated_at = @starts_at.to_time - 6.hours
    if @activated_at.sunday?
      @activated_at -= 2.days
    elsif @activated_at.saturday?
      @activated_at -= 1.day
    end

    @starts_at
  end

  def ends_at= val
    @parsing_message = false
    @ends_at = val.is_a?(Date) ? val : Date.parse(val)

    # set Autoresponder deactivation time at 18:00 of the last
    # day of the user's vacation
    @deactivated_at = @ends_at.to_time + 18.hours

    @ends_at
  end

  def activated_at= val
    @activated_at = to_time val
  end

  def deactivated_at= val
    @deactivated_at = to_time val
  end

  def message?
    !@message.to_s.empty?
  end

  def message= str
    @message = str.dup
  end

  def message
    @message || message_default
  end

  def message_default
    "I am on vacation from #{starts_at || 'NoDate'} through #{ends_at || 'NoDate'}."
  end

  def parsing_message?
    @parsing_message
  end

  def cancel
    @canceled = true
    @deactivated_at = Time.now - 1
  end

  def canceled?
    @canceled
  end

  def valid_request?
    @errors.empty?
  end

  def example?
    @fake
  end
  alias fake? example?

  def to_s
    out = []
    out << "account: #{account_name}"
    out << "email: #{account_email}"
    if canceled?
      out << "vacation: canceled"
      out << "deactivated_at: #{deactivated_at}"
    else
      out << "from: #{starts_at}"
      out << "till: #{ends_at}"
      out << "message:\n#{message}\nend_of_message"
      out << "*requested at: #{requested_at}"
      out << "*activated_at: #{activated_at}"
      out << "*deactivated_at: #{deactivated_at}"
      out << "*email path: #{email_file ? email_file.path : nil}"
    end
    out.join("\n")
  end

  # TODO: ugly. maybe move converter to VacationsFile?
  # after all, activation_time is VacationFile speak
  def for_config
    #.iso8601               #=> 2015-11-13T18:00:00+01:00
    fmt = "%F %T %z"        #=> 2015-11-25 18:00:00 +0100
    #fmt = "%d.%m.%Y %T %z" #=> 13.11.2015 18:00:00 +0100
    #puts deactivated_at.strftime(fmt)

    {
      account_name => {
        "email"             => account_email,
        "activation_time"   => activated_at   ? 
                                 activated_at.strftime(fmt)   : nil,
        "deactivation_time" => deactivated_at ? 
                                 deactivated_at.strftime(fmt) : nil,
        "message"           => message? ? message : nil
      }
    }
  end

  private

  def closed= v
    @closed = v
    @parsing_message = false  if @closed
  end

  def validate
    if canceled?
      # nothing to check

    else
      # check dates specified by the user
      if self.starts_at && self.ends_at

        if self.ends_at < self.starts_at
          @errors << "Vacation last day can not be before the first day"
        elsif self.ends_at < Date.today
          @error << "Vacation last day can not be in the past"
        end

      else
        unless self.starts_at
          @errors << "Request must contain the first date of vacation"
        end
        unless self.ends_at
          @errors << "Request must contain the last date of vacation"
        end
      end
    end
  end

  def to_time val
    val.is_a?(Time) ? val : Time.parse(val)
  end
end

######################################################################

class EmailAnalyser
  attr_accessor :account_name
  attr_accessor :debug

  def initialize
    @maildir_path = nil
    @maildir = nil
    @mydomains = []
    @vacations = []

    @debug = false
  end

  def maildir_path= path
    if File.directory? path
      @maildir_path = path
    else
      $stderr.puts "ERROR: Maildir not found: #{path}"
      exit 1
    end
  end

  def my_domains= domains
    @my_domains = domains.dup
  end

  def maildir
    @maildir ||= Maildir.new @maildir_path, false
  end

  def vacations
    @vacations.dup
  end

  def process_emails
    parse_emails
    analyse_vacations
    @vacations
  end

  private

  def parse_emails
    @vacations_from_emails = Hash.new{ |h,k| h[k] = [] }

    [:cur, :new].each do |loc|
      maildir.list(loc).each do |mailfile|

        if @debug
          puts "\n\n=== Processing Email ==="
          puts mailfile.path
        end

        msg = Mail.read mailfile.path

        unless mail_to_me? msg
#          puts "Not a mail to me"
          next
        end

        senders = senders_in_my_domain(msg)

        if senders.empty?
#          puts "Sender not in our domain: #{msg.from}"
          next
        end

        unless known_email? senders.first
#          puts "User email unknown: #{senders.first}"
          next
        end

        if msg.multipart?
          msg_body = msg.text_part || msg.html_part
        else
          msg_body = msg.body
        end

        vac = Vacation.new msg_body.decoded

        # TODO: in theory, there can be several addresses in the From
        # field and consequently in the senders array. But we ignore
        # this situation for the moment.
        
        # Keep the original sender address to be able to send a notice
        # back to the user.
        vac.account_email = senders.first

        # Store account name that will be used for:
        # - computing the path to the mailbox
        # - identifying vacation emails belonging to the same user
        vac.account_name = get_account_name(vac.account_email)

        # Set date on which request date was received.
        # Necessary for finding out the vacation request that is most
        # up-to-date and needs to be reacted.
        vac.requested_at = msg.date

        # Attach original email file, we may want to manipulate it
        vac.email_file = mailfile
        
        if @debug
          puts "=== Vacation object ==="
          #puts vac.inspect
          puts vac.to_s
        end
        
        @vacations_from_emails [vac.account_name] << vac
      end
    end
  end

  def analyse_vacations
    @vacations = []

    @vacations_from_emails.each do |account, vacs|
      if @debug
        puts "\n### #{vacs.length} vacation request(s) from account: #{account}"
      end

      # sort messages from a single account in descending order
      # so that the most recent message comes first
      vacs.sort_by!{ |vac| vac.requested_at }.reverse!
  
      howto_message_sent = false
      ignore_remaining_requests = false

      vacs.each do |vac|
        if @debug
          puts "== Vacation request user #{account}"
          puts vac.to_s
          puts "= yaml ="
          puts vac.for_config.to_yaml
          puts "\n"
        end
        
        if ignore_remaining_requests
          # skip

        elsif vac.valid_request?
          
          @vacations << vac
          ignore_remaining_requests = true
          
          if vac.canceled?
            Mailer.notify_vacation_autoresponder_canceled vac
          else
            Mailer.notify_vacation_autoresponder_accepted vac
          end
          
        elsif ! howto_message_sent
          # send HOWTO message if the user sent us an incorrect request,
          # but do it only once
          Mailer.send_howto_message vac
          howto_message_sent = true
          
        end

        # delete this message
        # we dont want to process it next time the script is run
        #vac.email_file.add_flag("T") # does not delete but merely marks as Trashed
        #vac.email_file.destroy # TODO: yes, uncomment
      end
    end
  end

  def my_email_addresses
    @my_email_addresses ||= @my_domains.map do |domain| 
      [@account_name, domain].join("@")
    end
  end

  def senders_in_my_domain msg
    # as per RFC, the From field can contain several addresses
    senders = msg.from.select do |addr|
      username, domain, other = addr.split '@'
      @my_domains.include?(domain.downcase)
    end
    senders
  end

  def mail_to_me? msg
    rcpt_addresses = [:to, :cc].map do |meth|
      msg.send(meth)
    end.flatten.compact.map(&:downcase)
    !(my_email_addresses - rcpt_addresses).empty?
  end

  def dovecot_accounts
    unless @dovecot_accounts
      @dovecot_accounts = {}
      load_dovecot_users
    end
    @dovecot_accounts
  end

  def load_dovecot_users
    return unless Conf.dovecot_users_file
    
    if File.exists? Conf.dovecot_users_file
      File.readlines(Conf.dovecot_users_file).each do |line|
        line = line.chomp.sub(/\s#.*/, "")
        if line =~ /^([^\s#:]+):.+user=([^\s@]+)@/
          login_name, new_name = $1.downcase, $2.downcase
          if @dovecot_accounts.key? login_name
            $stderr.puts "WARNING: Duplicate login names in #{Conf.dovecot_users_file}: #{login_name}"
          end
          @dovecot_accounts[login_name] = new_name
        end
      end
    else
      $stderr.puts "ERROR: Dovecot users file not found: #{Conf.dovecot_users_file}"
      exit 2
    end
  end

  # resolve to the same account synonyms
  # return nil if the email address is unknown
  def get_account_name email_addr
    account, other = email_addr.split '@'
    dovecot_accounts[account.downcase]
  end
 
  def known_email? email_addr
    !! get_account_name(email_addr)
  end
end

######################################################################
# other methods

def verboser msg
  if @options[:debug]
    puts msg
  end
end

def create_sieve_environment account
  verboser "Creating Sieve environment for #{account}"

  sieve_dir = Conf.sieve_dir account
  unless Dir.exists? sieve_dir
    Dir.mkdir sieve_dir
  end

  # write main.sieve file or make amendments to already existing file
  sieve_main_file = Conf.sieve_main_file account
  if File.exist? sieve_main_file
    verboser "ensuring that existing #{sieve_main_file} file contains relevant code"
    lines = IO.readlines sieve_main_file
    if SieveScript.insert_vacation! lines
      File.open sieve_main_file, "w+" do |file|
        file.puts lines.join("\n")
      end
    end

  else
    verboser "writing new #{sieve_main_file} file"
    File.open sieve_main_file, "w+" do |file|
      file.puts SieveScript.main
    end
  end

  # Link active sieve script to sieve/main.sieve
  sieve_active_file = Conf.sieve_active_file(account)
  verboser "Symlinking #{sieve_active_file} to #{sieve_main_file}"
  if File.exists? sieve_active_file
    File.delete sieve_active_file
  end
  File.symlink sieve_main_file, sieve_active_file
end

def install_sieve_script vac
  create_sieve_environment vac.account_name

  # write vacation.sieve file
  sieve_vacation_file = Conf.sieve_vacation_file vac.account_name
  verboser "Writing #{sieve_vacation_file} file"
  File.open sieve_vacation_file, "w+" do |file|
    # TODO: add from: @options[:from_senders] ?
    file.puts SieveScript.vacation text: vac.message
  end

  # amend main.sieve file
  sieve_main_file = Conf.sieve_main_file vac.account_name
  verboser "Activating vacation entry in #{sieve_main_file}"
  lines = IO.readlines sieve_main_file
  if SieveScript.activate_vacation! lines
    File.open sieve_main_file, "w+" do |file|
      file.puts lines.join("\n")
    end
  end

  Mailer.notify_vacation_autoresponder_activated vac
end

def uninstall_sieve_script vac

  # delete vacation.sieve
  sieve_vacation_file = Conf.sieve_vacation_file vac.account_name
  verboser "Deleting #{sieve_vacation_file} file"
  if File.exist? sieve_vacation_file
    File.delete sieve_vacation_file
  end

  # amend main.sieve
  sieve_main_file = Conf.sieve_main_file vac.account_name
  verboser "Deactivating vacation entry in #{sieve_main_file}"
  lines = IO.readlines sieve_main_file
  if SieveScript.deactivate_vacation! lines
    File.open sieve_main_file, "w+" do |file|
      file.puts lines.join("\n")
    end
  end

  Mailer.notify_vacation_autoresponder_deactivated vac
end

######################################################################
# process options

@options = {}

OptionParser.new do |opts|
  opts.banner = "
  This script analyses emails coming to special account and
1) generates vacations.yaml file that specifies when vacation autoresponder
   should be de/activated and for which user.
   See --show-vacations-example
2) de/activates vacation autoresponder by un/installing appropriate Sieve
   script in the mail account of appropriate user(s)
Important:
The script should be run either as root or as the same user as Dovecot runs.
The script works with Maildir format only.
Email in plain text is preferred (parsing of html not tested).
USAGE: #{File.basename($0)} [OPTIONS]
OPTIONS:
"

  opts.on('-h', '--help', 'display this message and exit') do
    puts opts
    exit 0
  end

  @options[:conf_file] = File.join ".", 'vacation_autoresponder.conf'
  opts.on('-c FILE', '--conf FILE',
          'path to configuration file (in YAML format)',
          "Default: #{@options[:conf_file]}") do |val|
    @options[:conf_file] = val
  end

  opts.on('--show-vacations-example', 'show example of vacations.yaml') do
    puts Vacation.example_entry_for_config.to_yaml
    exit 0
  end

  @options[:show_sieve_script] = false
  opts.on('--show-sieve-script',
          'show the bolerplate vacation.sieve script that will be installed',
          'In addition, try it with --from option.') do
    @options[:show_sieve_script] = true
  end

  @options[:from_senders] = nil
  opts.on('--from=email1,email2',
          'make sieve script active with specified sender addresses only.',
          'Especially useful for testing purposes.') do |addresses|
    @options[:from_senders] = addresses.split(",")
  end

  @options[:debug] = false
  opts.on('--debug', 'self explanatory') do
    @options[:debug] = true
  end

  opts.separator " "
end.parse!

if @options[:show_sieve_script]
  params = { text: 'I am on vacation' }
  if @options[:from_senders]
    params[:from] = @options[:from_senders]
  end
  puts SieveScript.vacation params
  exit 0
end

Conf.file = @options[:conf_file]

Mail.defaults do
  delivery_method :smtp, Conf.smtp
end

######################################################################
# MAIN

# load vacation requests from vacations.yaml
vacations = VacationsFile.new Conf.vacations_file

# find new vacation autoresponder requests in the mailbox
email_analyser = EmailAnalyser.new
email_analyser.account_name = Conf.service_account_name
email_analyser.maildir_path = Conf.service_mail_dir
email_analyser.my_domains = Conf.domains
#email_analyser.debug = @options[:debug]

email_analyser.process_emails

# merge vacation requests from the two above sources
vacations.add email_analyser.vacations

verboser "\n***** STEP 2: manage the Sieve scripts for *****\n"
verboser "Number of requests to process: #{vacations.length}"

# Now that we have a complete set of vacation requests, we want to
# to install/remove sieve scripts.
vacations.each do |vac|
  #puts vac.to_s

  if vac.deactivated_at.in_the_past?
    verboser "Deactivating autoresponder for #{vac.account_name}"
    uninstall_sieve_script vac
    vac.cancel  # will delete this entry from vacations.yaml

  elsif vac.activated_at.in_the_past?
    verboser "Activating autoresponder for #{vac.account_name}"
    install_sieve_script vac

  elsif vac.activated_at.in_the_future?
    verboser "Skipping #{vac.account_name}. Activation is still in the future"

  end
end

# write updated vacations.yaml
vacations.save

# EOF ################################################################
